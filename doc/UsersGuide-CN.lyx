#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass extbook
\begin_preamble
\usepackage[cm-default]{fontspec}
\usepackage{xunicode}
\usepackage{xltxtra}
\setmainfont[ItalicFont=KaiTi]{SimSun}
%\setmainfont[ItalicFont=KaiTi]{YaHei Consolas Hybrid}
%\setmainfont[BoldFont=KaiTi,ItalicFont=KaiTi]{SimSun}
%\setsansfont[BoldFont=KaiTi]{KaiTi}
%\setmonofont{KaiTi}

%其他中文设置%
\XeTeXlinebreaklocale “zh”%中文断行
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt%左右弹性间距
\usepackage{indentfirst}%段落首行缩进
\setlength{\parindent}{2em}%缩进两个字符

%编号语言、样式设置%
\numberwithin{equation}{section}%设置公式按章节进行编号
\numberwithin{figure}{section}% 按章节编号
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\language english
\inputencoding utf8-plain
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "zlog Users Guide CN"
\pdf_author "Hardy Simpson"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "unicode=false"
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\rightmargin 2cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
zlog使用攻略
\end_layout

\begin_layout Author
难易 著
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
适用于 zlog v1.0
\end_layout

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
有问题，在github上开个issue，或者写邮件到
\begin_inset CommandInset href
LatexCommand href
name "HardySimpson1984@gmail.com"
target "HardySimpson1984@gmail.com"
type "mailto:"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
zlog是什么？
\end_layout

\begin_layout Standard
zlog是一个高可靠性、性能、线程安全、灵活、概念清晰的纯C日志函数库。
\end_layout

\begin_layout Standard
事实上，在C的世界里面没有特别好的日志函数库（就像JAVA里面的的log4j，或者C++的log4cxx）。C程序员都喜欢用自己的轮子。printf就是个挺好的
轮子，但没办法通过配置改变日志的格式或者输出文件。syslog是个系统级别的轮子，不过速度慢，而且功能比较单调。
\end_layout

\begin_layout Standard
所以我写了zlog。
\end_layout

\begin_layout Standard
zlog在效率、功能、安全性上大大超过了log4c，并且是用c写成的，具有比较好的通用性。
\end_layout

\begin_layout Standard
zlog有这些特性：
\end_layout

\begin_layout Itemize
syslog分类模型，比log4j模型更加直接了当
\end_layout

\begin_layout Itemize
日志格式定制，类似于log4j的pattern layout
\end_layout

\begin_layout Itemize
多种输出，包括动态文件、静态文件、stdout、stderr、syslog、用户自定义输出函数
\end_layout

\begin_layout Itemize
运行时手动、自动刷新配置文件（同时保证安全）
\end_layout

\begin_layout Itemize
高性能，在我的笔记本上达到72'000条日志每秒, 大概是syslog(3)配合rsyslogd的200倍速度 
\end_layout

\begin_layout Itemize
用户自定义等级
\end_layout

\begin_layout Itemize
多线程和多进程环境下保证安全转档
\end_layout

\begin_layout Itemize
精确到微秒
\end_layout

\begin_layout Itemize
简单调用包装dzlog（一个程序默认只用一个分类）
\end_layout

\begin_layout Itemize
MDC，线程键-值对的表，可以扩展用户自定义的字段
\end_layout

\begin_layout Itemize
自诊断，可以在运行时输出zlog自己的日志和配置状态
\end_layout

\begin_layout Itemize
不依赖其他库，只要是个POSIX系统就成(当然还要一个C99兼容的vsnprintf)
\end_layout

\begin_layout Standard
相关链接：
\end_layout

\begin_layout Standard
软件下载：
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/downloads/HardySimpson/zlog/zlog-latest-stable.tar.gz"

\end_inset


\end_layout

\begin_layout Standard
上手指南：doc/GettingStart-CN.txt GettingStart-EN.txt
\end_layout

\begin_layout Standard
使用攻略：doc/UsersGuide-CN.pdf UsersGuide-EN.pdf
\end_layout

\begin_layout Standard
源代码：
\begin_inset CommandInset href
LatexCommand href
name "git@github.com:HardySimpson/zlog.git"
target "git@github.com:HardySimpson/zlog.git"

\end_inset


\end_layout

\begin_layout Standard
问题讨论区：
\begin_inset CommandInset href
LatexCommand href
name "https://github.com/HardySimpson/zlog/issues"
target "https://github.com/HardySimpson/zlog/issues"

\end_inset


\end_layout

\begin_layout Standard
英文主页：
\begin_inset CommandInset href
LatexCommand href
target "http://hardysimpson.github.com/zlog"

\end_inset


\end_layout

\begin_layout Standard
中文主页：
\begin_inset CommandInset href
LatexCommand href
name "http://www.oschina.net/p/zlog"
target "http://www.oschina.net/p/zlog"

\end_inset


\end_layout

\begin_layout Standard
作者博客：
\begin_inset CommandInset href
LatexCommand href
name "http://my.oschina.net/HardySimpson/blog"
target "http://my.oschina.net/HardySimpson/blog"

\end_inset


\end_layout

\begin_layout Standard
邮箱：
\begin_inset CommandInset href
LatexCommand href
name "HardySimpson1984@gmail.com"
target "HardySimpson1984@gmail.com"
type "mailto:"

\end_inset


\end_layout

\begin_layout Section
zlog 1.0 发布说明
\end_layout

\begin_layout Enumerate
zlog是基于POSIX的。目前我手上有的环境只有AIX和linux。在其他的系统下（FreeBSD, NetBSD, OpenBSD, OpenSolaris
, Mac OS X...）估计也能行，有问题欢迎探讨。
\end_layout

\begin_layout Enumerate
zlog使用了一个C99兼容的vsnprintf。也就是说如果缓存大小不足，vsnprintf将会返回目标字符串应有的长度（不包括'
\backslash
0')。如果在你的系统上vsnprintf不是这么运作的，zlog就不知道怎么扩大缓存。如果在目标缓存不够的时候vsnprintf返回-1，zlog就会认为这次
写入失败。幸运的是目前大多数c标准库符合C99标准。glibc 2.1,libc on AIX, libc on freebsd...都是好的，不过glibc2.0不是。
在这种情况下，用户需要自己来装一个C99兼容的vsnprintf，来crack这个函数库。我推荐
\begin_inset CommandInset href
LatexCommand href
name "ctrio"
target "http://sourceforge.net/projects/ctrio/"

\end_inset

, 或者
\begin_inset CommandInset href
LatexCommand href
name "C99-snprintf"
target "http://www.jhweiss.de/software/snprintf.html"

\end_inset

。只要改buf.c就行，祝好运！
\end_layout

\begin_layout Enumerate
zlog1.0和0.9不是兼容的。因为我增加了__func__，这样在C99情况下能打印函数名。我还改了配置文件的格式，对配置文件分节，更加清晰易懂。如果你是zlo
g0.9的用户，想要升级到1.0，那就需要重新编译你的程序链接新的库（你的源代码倒不用改，因为几个输出日志的宏和0.9还是一样）。
\end_layout

\begin_layout Chapter
zlog不是什么？
\end_layout

\begin_layout Standard
zlog的目标是成为一个简而精的日志函数库，她不会直接支持网络输出或者写入数据库，她不会直接支持日志内容的过滤和解析。
\end_layout

\begin_layout Standard
原因很明显，日志库是被应用程序调用的，所有花在日志库上的时间都是应用程序运行时间的一部分，而上面说的这些操作都很费时间，会拖慢应用程序的速度。这些事儿应该在别的
进程或者别的机器上做。
\end_layout

\begin_layout Standard
如果你需要这些特性，我建议使用rsyslog，一个系统级别的日志搜集、过滤、存储软件，当然这是单独的进程，不是应用程序的一部分。
\end_layout

\begin_layout Standard
目前我正在考虑怎么让zlog和rsyslog合适的对接，传统的syslog(3)行，但不够优雅。当然我也考虑让应用程序挂一些输出函数到zlog上。有什么好想法，
告诉我！
\end_layout

\begin_layout Chapter
Hello World
\end_layout

\begin_layout Section
编译和安装zlog
\end_layout

\begin_layout Standard
下载
\begin_inset CommandInset href
LatexCommand href
name "zlog-latest-stable.tar.gz"
target "https://github.com/downloads/HardySimpson/zlog/zlog-latest-stable.tar.gz"
type "file:"

\end_inset


\end_layout

\begin_layout LyX-Code
$ tar -zxvf zlog-latest-stable.tar.gz
\end_layout

\begin_layout LyX-Code
$ cd zlog-x.x.x/
\end_layout

\begin_layout LyX-Code
$ ./configure --prefix=[where u wanna install it] 
\backslash

\end_layout

\begin_layout LyX-Code
      --enable-test 
\end_layout

\begin_layout LyX-Code
$ make 
\end_layout

\begin_layout LyX-Code
$ sudo make install
\end_layout

\begin_layout Standard
--enable-test用了的话，测试程序会被编译。这些程序是很好的zlog的使用案例。
\end_layout

\begin_layout LyX-Code
# add one line
\end_layout

\begin_layout LyX-Code
$ sudo vi /etc/ld.so.conf
\end_layout

\begin_layout LyX-Code
/usr/local/lib
\end_layout

\begin_layout LyX-Code
$ sudo ldconfig
\end_layout

\begin_layout Standard
在你的程序运行之前，保证libzlog.so在系统的动态链接库加载器可以找到的目录下。上面的命令适用于linux，别的系统自己想办法。
\end_layout

\begin_layout Itemize
对于zlog库开发者，如果你在别的目录而不是在源代码目录编译(平行编译，parallel building)，编译完之后要把源代码测试目录的配置文件复制过来。否
则运行测试程序会报错，找不到配置文件。
\end_layout

\begin_layout LyX-Code
$ tar -zxvf zlog-0.9.0.tar.gz
\end_layout

\begin_layout LyX-Code
$ mkdir build && cd build
\end_layout

\begin_layout LyX-Code
$ ../zlog-0.9.0/configure --prefix=[where u wanna install it] 
\backslash

\end_layout

\begin_layout LyX-Code
      --enable-test 
\end_layout

\begin_layout LyX-Code
$ cp ../zlog-0.9.0/test/*.conf ./test/
\end_layout

\begin_layout LyX-Code
$ cd test
\end_layout

\begin_layout LyX-Code
$ ./test_hello
\end_layout

\begin_layout LyX-Code
hello, zlog
\end_layout

\begin_layout Itemize
对于zlog库开发者，如果是从github上直接下载，那就不会有configure这个脚本，因为这个脚本是由auto tools从configure.ac等源文件
生成的。这时候你的环境上就需要有automake, autoconf等工具来生成configure
\end_layout

\begin_layout LyX-Code
$ git clone git@github.com:HardySimpson/zlog.git
\end_layout

\begin_layout Standard
或者从这个地址下载zip包 
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/HardySimpson/zlog/zipball/master"
type "file:"

\end_inset


\end_layout

\begin_layout Standard
解压后，执行命令来生成configure
\end_layout

\begin_layout LyX-Code
$ cd zlog
\end_layout

\begin_layout LyX-Code
$ ./autogen.sh
\end_layout

\begin_layout Standard
后面的步骤就和本节一开始描述的一样了。
\end_layout

\begin_layout Section
应用程序调用和链接zlog
\end_layout

\begin_layout Standard
应用程序使用zlog很简单，只要在C文件里面加一行。
\end_layout

\begin_layout LyX-Code
#include 
\begin_inset Quotes eld
\end_inset

zlog.h
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
如果你的系统有pkgconfig，可以在makefile里面这么写
\end_layout

\begin_layout LyX-Code
CFLAGS += $(shell pkg-config --cflags zlog)
\end_layout

\begin_layout LyX-Code
LDFLAGS += $(shell pkg-config --libs zlog)
\end_layout

\begin_layout Standard
如果没有的话，手工链接的命令是
\end_layout

\begin_layout LyX-Code
$ cc -c -o app.o app.c -I[where zlog.h is put, commonly /usr/local/include]
\end_layout

\begin_layout LyX-Code
$ cc -o app app.o -L[where libzlog.so is put, commonly /usr/local/lib] -lzlog
 -lpthread
\end_layout

\begin_layout Section
Hello World 代码
\begin_inset CommandInset label
LatexCommand label
name "sec:Hello-World-代码"

\end_inset


\end_layout

\begin_layout Standard
这些代码在$(top_builddir)/test/test_hello.c, test_hello.conf
\end_layout

\begin_layout Enumerate
写一个C文件：
\end_layout

\begin_deeper
\begin_layout LyX-Code
$ vi test_hello.c
\end_layout

\begin_layout LyX-Code
#include <stdio.h> 
\end_layout

\begin_layout LyX-Code
#include "zlog.h"
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
int main(int argc, char** argv)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_deeper
\begin_layout LyX-Code
int rc;
\end_layout

\begin_layout LyX-Code
zlog_category_t *c;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
rc = zlog_init("test_hello.conf");
\end_layout

\begin_layout LyX-Code
if (rc) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
printf("init failed
\backslash
n");
\end_layout

\begin_layout LyX-Code
return -1;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
c = zlog_get_category("my_cat");
\end_layout

\begin_layout LyX-Code
if (!c) {
\end_layout

\begin_layout LyX-Code
printf("get cat fail
\backslash
n");
\end_layout

\begin_deeper
\begin_layout LyX-Code
zlog_fini();
\end_layout

\begin_layout LyX-Code
return -2;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
ZLOG_INFO(c, "hello, zlog");
\end_layout

\begin_layout LyX-Code
zlog_fini();
\end_layout

\begin_layout LyX-Code
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code
} 
\end_layout

\end_deeper
\begin_layout Enumerate
写一个配置文件，放在和test_hello.c同样的目录下:
\end_layout

\begin_deeper
\begin_layout LyX-Code
$ vi test_hello.conf
\end_layout

\begin_layout LyX-Code
[formats]
\end_layout

\begin_layout LyX-Code
simple = "%m%n"
\end_layout

\begin_layout LyX-Code
[rules]
\end_layout

\begin_layout LyX-Code
my_cat.DEBUG    >stdout; simple
\end_layout

\end_deeper
\begin_layout Enumerate
编译、然后运行!
\end_layout

\begin_deeper
\begin_layout LyX-Code
$ cc -c -o test_hello.o test_hello.c -I/usr/local/include
\end_layout

\begin_layout LyX-Code
$ cc -o test_hello test_hello.o -L/usr/local/lib -lzlog
\end_layout

\begin_layout LyX-Code
$ ./test_hello
\end_layout

\begin_layout LyX-Code
hello, zlog
\end_layout

\end_deeper
\begin_layout Section
更简单的Hello World
\end_layout

\begin_layout Standard
这个例子在$(top_builddir)/test/test_default.c, test_default.conf.
 源代码是： 
\end_layout

\begin_layout LyX-Code
#include <stdio.h>
\end_layout

\begin_layout LyX-Code
#include "zlog.h"
\end_layout

\begin_layout LyX-Code
int main(int argc, char** argv)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_deeper
\begin_layout LyX-Code
int rc;
\end_layout

\begin_layout LyX-Code
rc = dzlog_init("test_default.conf", "my_cat");
\end_layout

\begin_layout LyX-Code
if (rc) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
printf("init failed
\backslash
n");
\end_layout

\begin_layout LyX-Code
return -1;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
DZLOG_INFO("hello, zlog");
\end_layout

\begin_layout LyX-Code
zlog_fini();
\end_layout

\begin_layout LyX-Code
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code
} 
\end_layout

\begin_layout Standard
配置文件是test_default.conf，和test_hello.conf一模一样，最后执行程序的输出也一样。区别在于这里用了dzlog API，内含一个默认的
zlog_category_t。详见
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:dzlog接口"

\end_inset

。
\end_layout

\begin_layout Chapter
Syslog 模型
\end_layout

\begin_layout Section
分类(Category)、规则(Rule)和格式(Format)
\end_layout

\begin_layout Standard
zlog有3个重要的概念：分类(Category)、规则(Rule)和格式(Format)。
\end_layout

\begin_layout Standard
分类(Category)用于区分不同的输入。代码中的分类变量的名字是一个字符串，在一个程序里面可以通过获取不同的分类名的category用来后面输出不同分类的日
志，用于不同的目的。
\end_layout

\begin_layout Standard
格式(Format)是用来描述输出日志的格式，比如是否有带有时间戳，是否包含文件位置信息等，上面的例子里面的格式simple就是简单的用户输入的信息+换行符。
\end_layout

\begin_layout Standard
规则(Rule)则是把分类、级别、输出文件、格式组合起来，决定一条代码中的日志是否输出，输出到哪里，以什么格式输出。
\end_layout

\begin_layout Standard
所以，当程序执行下面的语句的时候
\end_layout

\begin_layout LyX-Code
zlog_category_t *c;
\end_layout

\begin_layout LyX-Code
c = zlog_get_category("my_cat");
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(c, "hello, zlog");
\end_layout

\begin_layout Standard
zlog会找到c的名字是
\begin_inset Quotes eld
\end_inset

my_cat
\begin_inset Quotes erd
\end_inset

，对应的配置文件中的规则是
\end_layout

\begin_layout LyX-Code
[rules]
\end_layout

\begin_layout LyX-Code
my_cat.DEBUG    >stdout; simple
\end_layout

\begin_layout Standard
然后库会检查，目前这条日志的级别是否符合规则中的级别来决定是否输出。因为INFO>=DEBUG，所以这条日志会被输出。并且根据这条规则，会被输出到stdout（
标准输出） ，输出的格式是simple，在配置文件中定义是
\end_layout

\begin_layout LyX-Code
[formats]
\end_layout

\begin_layout LyX-Code
simple = "%m%n" 
\end_layout

\begin_layout Standard
最后在屏幕上打印
\end_layout

\begin_layout LyX-Code
hello, zlog
\end_layout

\begin_layout Standard
这就是整个过程。用户要做就是写自己的信息。日志往哪里输出，以什么格式输出，都是库和配置文件来完成的。
\end_layout

\begin_layout Section
syslog模型和log4j模型的区别
\end_layout

\begin_layout Standard
好，那么目前这个模型和syslog有什么关系呢？至今为止，这个模型还是比较像log4j。log4j的模型里面有logger, appender和layout。区
别在于，在log4j里面，代码中的logger和配置中的logger是一一对应的，并且一个logger有唯一的级别。一对一关系是log4j, log4cxx,
 log4cpp, log4cplus, log4net的唯一选择。
\end_layout

\begin_layout Standard
但这种模型是不灵活的，他们发明了过滤器（filters）来弥补，但这只能把事情弄得更加混乱。所以让我们把目光转回syslog的模型，这是一个设计的很简易正确的模
型。
\end_layout

\begin_layout Standard
继续上一节的例子，如果在zlog的配置文件中有这么2行规则：
\end_layout

\begin_layout LyX-Code
[rules]
\end_layout

\begin_layout LyX-Code
my_cat.DEBUG     >stdout; simple
\end_layout

\begin_layout LyX-Code
my_cat.INFO      >stdout;
\end_layout

\begin_layout Standard
然后，一行代码会产生两行输出：
\end_layout

\begin_layout LyX-Code
hello, zlog
\end_layout

\begin_layout LyX-Code
2012-05-29 10:41:36 INFO [11288:test_hello.c:41] hello, zlog
\end_layout

\begin_layout Standard
现在一个代码中的分类对应配置文件中的两条规则。log4j的用户可能会说：“这很好，但是只要在log4j里面放两个appender也能做的一样。“所以继续看下一个
例子：
\end_layout

\begin_layout LyX-Code
[rules]
\end_layout

\begin_layout LyX-Code
my_cat.WARN     
\begin_inset Quotes eld
\end_inset

/var/log/aa.log
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
my_cat.DEBUG    
\begin_inset Quotes eld
\end_inset

/var/log/bb.log
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
代码是：
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(c, "info, zlog");
\end_layout

\begin_layout LyX-Code
ZLOG_DEBUG(c, "debug, zlog");
\end_layout

\begin_layout Standard
最后，在aa.log中只有一条日志
\end_layout

\begin_layout LyX-Code
2012-05-29 10:41:36 INFO [11288:test_hello.c:41] info, zlog
\end_layout

\begin_layout Standard
但在bb.log里面有两条
\end_layout

\begin_layout LyX-Code
2012-05-29 10:41:36 INFO [11288:test_hello.c:41] info, zlog
\end_layout

\begin_layout LyX-Code
2012-05-29 10:41:36 DEBUG [11288:test_hello.c:42] debug, zlog
\end_layout

\begin_layout Standard
从这个例子能看出来区别。log4j无法轻易的做到这一点。在zlog里面，一个分类可以对应多个规则，每个规则有自己的级别、输出和格式。这就让用户能按照需求过滤、多
渠道输出自己的所有日志。
\end_layout

\begin_layout Section
扩展syslog模型
\end_layout

\begin_layout Standard
所以到现在你能看出来zlog的模型更像syslog的模型。不幸的是，在syslog里面，设施（facility）是个int型，而且必须从系统定义的那几种里面选择
。zlog走的远一点，用一个字符串来标识分类。
\end_layout

\begin_layout Standard
syslog有一个通配符
\begin_inset Quotes eld
\end_inset

*
\begin_inset Quotes erd
\end_inset

，匹配所有的设施（facility）。zlog里面也一样，
\begin_inset Quotes eld
\end_inset

*
\begin_inset Quotes erd
\end_inset

匹配所有分类。这提供了一个很方便的办法来重定向你的系统中各个组件的错误。只要这么写：
\end_layout

\begin_layout LyX-Code
[rules]
\end_layout

\begin_layout LyX-Code
*.error    
\begin_inset Quotes eld
\end_inset

/var/log/error.log
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
zlog强大而独有的特性是上下级分类匹配。如果你的分类是这样的：
\end_layout

\begin_layout LyX-Code
c = zlog_get_category("my_cat");
\end_layout

\begin_layout Standard
然后配置文件是这样的
\end_layout

\begin_layout LyX-Code
[rules]
\end_layout

\begin_layout LyX-Code
my_cat.*      
\begin_inset Quotes eld
\end_inset

/var/log/my_cat.log
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
my_.NOTICE    
\begin_inset Quotes eld
\end_inset

/var/log/my.log
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
这两条规则都匹配c分类-
\begin_inset Quotes eld
\end_inset

my_cat
\begin_inset Quotes erd
\end_inset

。通配符
\begin_inset Quotes eld
\end_inset

_
\begin_inset Quotes erd
\end_inset

 表示上级分类。 
\begin_inset Quotes eld
\end_inset

my_
\begin_inset Quotes erd
\end_inset

是
\begin_inset Quotes eld
\end_inset

my_cat
\begin_inset Quotes erd
\end_inset

和
\begin_inset Quotes eld
\end_inset

my_dog
\begin_inset Quotes erd
\end_inset

的上级分类。还有一个通配符是
\begin_inset Quotes eld
\end_inset

!
\begin_inset Quotes erd
\end_inset

，详见
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:分类匹配"

\end_inset


\end_layout

\begin_layout Chapter
配置文件
\end_layout

\begin_layout Standard
大部分的zlog的行为取决于配置文件：把日志打到哪里去，用什么格式，怎么转档。配置文件是zlog的黑话，我尽量把这个黑话设计的简单明了。这是个配置文件例子：
\end_layout

\begin_layout LyX-Code
# comments
\end_layout

\begin_layout LyX-Code
[global]
\end_layout

\begin_layout LyX-Code
strict init = true
\end_layout

\begin_layout LyX-Code
buffer min = 1024
\end_layout

\begin_layout LyX-Code
buffer max = 2MB
\end_layout

\begin_layout LyX-Code
rotate lock file = /tmp/zlog.lock
\end_layout

\begin_layout LyX-Code
default format = "%d(%F %T.%l) %-6P (%c:%F:%L) - %m%n"
\end_layout

\begin_layout LyX-Code
file perms = 600
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
[levels]
\end_layout

\begin_layout LyX-Code
TRACE = 10
\end_layout

\begin_layout LyX-Code
CRIT = 130, LOG_CRIT
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
[formats]
\end_layout

\begin_layout LyX-Code
simple = "%m%n"
\end_layout

\begin_layout LyX-Code
normal = "%d(%F %T.%l) %m%n"
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
[rules]
\end_layout

\begin_layout LyX-Code
default.*               >stdout; simple
\end_layout

\begin_layout LyX-Code
*.*                     "%12.2E(HOME)/log/%c.log", 1MB*12; simple
\end_layout

\begin_layout LyX-Code
my_.INFO                >stderr;
\end_layout

\begin_layout LyX-Code
my_cat.!ERROR           "/var/log/aa.log"
\end_layout

\begin_layout LyX-Code
my_dog.=DEBUG           >syslog, LOG_LOCAL0; simple
\end_layout

\begin_layout LyX-Code
my_mice.*               @user_define;
\end_layout

\begin_layout Standard
有关单位：当设置内存大小或者大数字时，可以设置1k 5GB 4M这样的单位：
\end_layout

\begin_layout LyX-Code
# 1k => 1000 bytes 
\end_layout

\begin_layout LyX-Code
# 1kb => 1024 bytes 
\end_layout

\begin_layout LyX-Code
# 1m => 1000000 bytes 
\end_layout

\begin_layout LyX-Code
# 1mb => 1024*1024 bytes
\end_layout

\begin_layout LyX-Code
# 1g => 1000000000 bytes 
\end_layout

\begin_layout LyX-Code
# 1gb => 1024*1024*1024 byte
\end_layout

\begin_layout Standard
单位是大小写不敏感的，所以1GB 1Gb 1gB是等效的。
\end_layout

\begin_layout Section
全局参数
\end_layout

\begin_layout Standard
全局参数以[global]开头。[]代表一个节的开始，四个小节的顺序不能变，依次为global-levels-formats-rules。这一节可以忽略不写。语
法为
\end_layout

\begin_layout LyX-Code
(key) = (value)
\end_layout

\begin_layout Itemize
strict init
\end_layout

\begin_layout Standard
如果
\begin_inset Quotes eld
\end_inset

strict init
\begin_inset Quotes erd
\end_inset

是true，zlog_init()将会严格检查所有的格式和规则，任何错误都会导致zlog_init() 失败并且返回-1。当
\begin_inset Quotes eld
\end_inset

strict init
\begin_inset Quotes erd
\end_inset

是false的时候，zlog_init()会忽略错误的格式和规则。 这个参数默认为true。
\end_layout

\begin_layout Itemize
reload conf period
\end_layout

\begin_layout Standard
这个选项让zlog能在一段时间间隔后自动重载配置文件。重载的间隔以每进程写日志的次数来定义。当写日志次数到了一定值后，内部将会调用zlog_reload()进行
重载。每次zlog_reload()或者zlog_init()之后重新计数累加。因为zlog_reload()是原子性的，重载失败继续用当前的配置信息，所以自动
重载是安全的。默认值是0，自动重载是关闭的。
\end_layout

\begin_layout Itemize
buffer min
\end_layout

\begin_layout Itemize
buffer max
\end_layout

\begin_layout Standard
zlog在堆上为每个线程申请缓存。“buffer min”是单个缓存的最小值，zlog_init()的时候申请这个长度的内存。写日志的时候，如果单条日志长度大于
缓存，缓存会自动扩充，直到到“buffer max
\begin_inset Quotes erd
\end_inset

。 单条日志再长超过“buffer max
\begin_inset Quotes erd
\end_inset

就会被截断。如果 
\begin_inset Quotes eld
\end_inset

buffer max
\begin_inset Quotes erd
\end_inset

 是 0，意味着不限制缓存，每次扩充为原先的2倍，直到这个进程用完所有内存为止。缓存大小可以加上 KB, MB 或 GB这些单位。默认来说
\begin_inset Quotes eld
\end_inset

buffer min
\begin_inset Quotes erd
\end_inset

是 1K ， 
\begin_inset Quotes eld
\end_inset

buffer max
\begin_inset Quotes erd
\end_inset

 是2MB。
\end_layout

\begin_layout Itemize
rotate lock file
\end_layout

\begin_layout Standard
这个选项指定了一个锁文件，用来保证多进程情况下日志安全转档。zlog会在zlog_init()时候以读写权限打开这个文件。确认你执行程序的用户有权限创建和读写这
个文件。转档日志的伪代码是：
\end_layout

\begin_layout LyX-Code
write(log_file, a_log);
\end_layout

\begin_layout LyX-Code
if (log_file > 1M)
\end_layout

\begin_deeper
\begin_layout LyX-Code
if (pthread_mutex_lock succ && fcntl_lock(lock_file) succ)
\end_layout

\begin_deeper
\begin_layout LyX-Code
if (log_file > 1M) //check again, prevent other process already rotate it
\end_layout

\begin_deeper
\begin_layout LyX-Code
rotate(log_file)
\end_layout

\end_deeper
\begin_layout LyX-Code
fcntl_unlock(lock_file)
\end_layout

\begin_layout LyX-Code
pthread_mutex_unlock
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
mutex_lock用于多线程， fcntl_lock用于多进程。fcntl_lock是POSIX建议锁。详见man 3 fcntl。这个锁是全系统有效的。在某
个进程意外死亡后，操作系统会释放此进程持有的锁。这就是我为什么用fcntl锁来保证安全转档。进程需要对锁文件有读写权限。
\end_layout

\begin_layout Standard
默认来说，rotate lock file = self。在这种情况下，zlog不会创建任何锁文件，用配置文件作为锁文件。fcntl是建议锁，所以用户可以自由的
修改存储他们的配置文件。一般来说，单个日志文件不会被不同操作系统用户的进程转档，所以用配置文件作为锁文件是安全的。
\end_layout

\begin_layout Standard
如果你设置其他路径作为锁文件，例如/tmp/zlog.lock，zlog会在zlog_init()的时候创建这个文件。如果有多个操作系统用户的进程需要转档同一个日
志文件，确认这个锁文件对于多个用户都可读写。默认值是/tmp/zlog.lock。
\end_layout

\begin_layout Itemize
default format
\end_layout

\begin_layout Standard
这个参数是缺省的日志格式，默认值为：
\end_layout

\begin_layout LyX-Code
"%d(%F %T) %V [%p:%F:%L] %m%n"
\end_layout

\begin_layout Standard
这种格式产生的输出类似这样：
\end_layout

\begin_layout LyX-Code
2012-02-14 17:03:12 INFO [3758:test_hello.c:39] hello, zlog
\end_layout

\begin_layout Itemize
file perms
\end_layout

\begin_layout Standard
这个指定了创建日志文件的缺省访问权限。必须注意的是最后的产生的日志文件的权限为
\begin_inset Quotes eld
\end_inset

file perms
\begin_inset Quotes erd
\end_inset

& ~umask。默认为600，只允许当前用户读写。
\end_layout

\begin_layout Itemize
fsync period
\end_layout

\begin_layout Standard
在每条规则写了一定次数的日志到文件后，zlog会调用fsync(3)来让操作系统马上把数据写到硬盘。次数是每条规则单独统计的，并且在zlog_reload()后
会被清0。必须指出的是，在日志文件名是动态生成或者被转档的情况下，zlog不能保证把所有文件都搞定，zlog只fsync()那个时候刚刚write()的文件描述
符。这提供了写日志速度和数据安全性之间的平衡。例子：
\end_layout

\begin_layout LyX-Code
$ time ./test_press_zlog 1 10 100000
\end_layout

\begin_layout LyX-Code
real	0m1.806s
\end_layout

\begin_layout LyX-Code
user	0m3.060s 
\end_layout

\begin_layout LyX-Code
sys	 0m0.270s
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
$ wc -l press.log  
\end_layout

\begin_layout LyX-Code
1000000 press.log  
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
$ time ./test_press_zlog 1 10 100000 #fsync period = 1K
\end_layout

\begin_layout LyX-Code
real	0m41.995s 
\end_layout

\begin_layout LyX-Code
user	0m7.920s 
\end_layout

\begin_layout LyX-Code
sys	 0m0.990s
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
$ time ./test_press_zlog 1 10 100000 #fsync period = 10K
\end_layout

\begin_layout LyX-Code
real	0m6.856s 
\end_layout

\begin_layout LyX-Code
user	0m4.360s 
\end_layout

\begin_layout LyX-Code
sys	 0m0.550s
\end_layout

\begin_layout Standard
如果你极度在乎安全而不是速度的话，用同步IO文件，见
\begin_inset CommandInset ref
LatexCommand ref
reference "ite:同步IO文件"

\end_inset

。默认值是0，由操作系统来决定什么时候刷缓存到文件。
\end_layout

\begin_layout Section
日志等级自定义
\end_layout

\begin_layout Standard
这一节以[levels]开始。用于定义用户自己的日志等级，建议和用户自定义的日志记录宏一起使用。这一节可以忽略不写。语法为：
\end_layout

\begin_layout LyX-Code
(level string) = (level int), (syslog level, optional)
\end_layout

\begin_layout Standard
(level int)必须在[1,253]这个范围内，越大越着重要。(syslog level)是可选的，如果不设默认为LOG_DEBUG。
\end_layout

\begin_layout Standard
详见
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:用户自定义等级"

\end_inset

。
\end_layout

\begin_layout Section
格式(Formats)
\end_layout

\begin_layout Standard
这一节以[formats]开始。用来定义日志的格式。语法为：
\end_layout

\begin_layout LyX-Code
(name) = 
\begin_inset Quotes eld
\end_inset

(actual formats)
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
很好理解，(name)被后面的规则使用。(name)必须由数字和字母组成，下划线
\begin_inset Quotes erd
\end_inset

_
\begin_inset Quotes erd
\end_inset

也算字母。(actual format)前后需要有双引号。 (actual formats)可以由转换字符组成，见下一节。
\end_layout

\begin_layout Section
转换格式串
\begin_inset CommandInset label
LatexCommand label
name "sec:转换格式串"

\end_inset


\end_layout

\begin_layout Standard
转换格式串的设计是从C的printf函数里面抄来的。一个转换格式串由文本字符和转换说明组成。
\end_layout

\begin_layout Standard
转换格式串用在规则的日志文件路径和输出格式(format)中。
\end_layout

\begin_layout Standard
你可以把任意的文本字符放到转换格式串里面。
\end_layout

\begin_layout Standard
每个转换说明都是以百分号(%)打头的，后面跟可选的宽度修饰符，最后以转换字符结尾。转换字符决定了输出什么数据，例如分类名、级别、时间日期、进程号等等。宽度修饰符
控制了这个字段的最大最小宽度、左右对齐。下面是简单的例子。
\end_layout

\begin_layout Standard
如果转换格式串是：
\end_layout

\begin_layout LyX-Code
"%d(%m-%d %T) %-5P [%p:%F:%L] %m%n".
\end_layout

\begin_layout Standard
源代码中的写日志语句是：
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(c, "hello, zlog");
\end_layout

\begin_layout Standard
将会输出：
\end_layout

\begin_layout LyX-Code
02-14 17:17:42 INFO  [4935:test_hello.c:39] hello, zlog
\end_layout

\begin_layout Standard
可以注意到，在文本字符和转换说明之间没有显式的分隔符。zlog解析的时候知道哪里是转换说明的开头和结尾。在这个例子里面%-5p这个转换说明决定了日志级别要被左对
齐，占5个字符宽。 
\end_layout

\begin_layout Subsection
转换字符
\end_layout

\begin_layout Standard
可以被辨认的转换字符是
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="19" columns="3">
<features islongtable="true">
<column alignment="center" valignment="top" width="10text%">
<column alignment="center" valignment="top" width="50text%">
<column alignment="center" valignment="top" width="40text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
字符
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
效果
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
例子
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
分类名 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aa_bb
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%d
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
打日志的时间。这个后面要跟一对小括号()内含说明具体的日期格式。就像%d(%F)或者%d(%m-%d %T)。如果不跟小括号，默认是%d(%F
 %T)。括号内的格式和 strftime(3)的格式一致，就是增加了%us表示微秒，还有
\end_layout

\begin_layout Plain Layout
%ms表示毫秒。详见
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:时间字符"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%d(%F) 2011-12-01
\end_layout

\begin_layout Plain Layout
%d(%m-%d %T) 12-01 17:17:42
\end_layout

\begin_layout Plain Layout
%d(%T.ms) 17:17:42.035
\end_layout

\begin_layout Plain Layout
%d 2012-02-14 17:03:12
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
环境变量，后面也要跟小括号，内涵环境变量的键。变量的值在zlog_init()的时候就求出来了。所以只含有%E的文件名被认为是静态路径文件，相比动态路径文件写日
志会有一定的性能提升。
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%E(HOME) /home/harry
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
源代码文件名，来源于__FILE__宏。在某些编译器下 __FILE__是绝对路径。用$f来去掉目录只保留文件名，或者编译器有选项可以调节
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
test_hello.c
\end_layout

\begin_layout Plain Layout
或者在某些编译器下
\end_layout

\begin_layout Plain Layout
/home/zlog/src/test/test_hello.c
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
源代码文件名，输出$F最后一个'/'后面的部分。当然这会有一定的性能损失
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
test_hello.c
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%H
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
主机名，来源于 gethostname(2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
zlog-dev
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%L
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
源代码行数，来源于__LINE__宏
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
135
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
用户日志，用户从zlog函数输入的日志。
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
hello, zlog
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%M
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MDC (mapped diagnostic context)，每个线程一张键值对表，输出键相对应的值。后面必需跟跟一对小括号()内含键。例如
 %M(clientNumber) ，clientNumbe是键。 详见 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:MDC"

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%M(clientNumber) 12345
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
换行符，目前还不支持windows换行符
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
n
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%p
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
进程ID，来源于getpid()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2134
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
调用函数名，来自于__func__(C99)或者__FUNCTION__(gcc)，如果编译器支持的话。
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
main
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%V
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
日志级别，大写
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INFO
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
日志级别，小写
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
info
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16进制表示的线程ID，来源于pthread_self()
\end_layout

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

0x%x
\begin_inset Quotes erd
\end_inset

,(unsigned int) pthread_t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0xba01e700
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
相当于%t,不过是以长整型表示的
\end_layout

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

%lu
\begin_inset Quotes erd
\end_inset

, (unsigned long) pthread_t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
140633234859776
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
一个百分号
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%[其他字符]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
解析为错误，zlog_init()将会失败
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
宽度修饰符 
\end_layout

\begin_layout Standard
一般来说数据按原样输出。不过，有了宽度修饰符，就能够控制最小字段宽度、最大字段宽度和左右对齐。当然这要付出一定的性能代价。
\end_layout

\begin_layout Standard
可选的宽度修饰符放在百分号和转换字符之间。
\end_layout

\begin_layout Standard
第一个可选的宽度修饰符是左对齐标识，减号(-)。然后是可选的最小字段宽度，这是一个十进制数字常量，表示最少有几个字符会被输出。如果数据本来没有那么多字符，将会填
充空格（左对齐或者右对齐）直到最小字段宽度为止。默认是填充在左边也就是右对齐。当然你也可以使用左对齐标志，指定为填充在右边来左对齐。填充字符为空格(space)
。如果数据的宽度超过最小字段宽度，则按照数据的宽度输出，永远不会截断数据。
\end_layout

\begin_layout Standard
这种行为可以用最大字段宽度来改变。最大字段宽度是放在一个句点号(.)后面的十进制数字常量。如果数据的宽度超过了最大字段宽度，则尾部多余的字符（超过最大字段宽度的部
分）将会被截去。 最大字段宽度是8，数据的宽度是10，则最后两个字符会被丢弃。假如这种行为和C的printf是一样的，把后面的部分截断。
\end_layout

\begin_layout Standard
下面是各种宽度修饰符和分类转换字符配合一起用的例子。
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="5">
<features>
<column alignment="center" valignment="top" width="15text%">
<column alignment="center" valignment="top" width="10text%">
<column alignment="center" valignment="top" width="10text%">
<column alignment="center" valignment="top" width="10text%">
<column alignment="center" valignment="top" width="60text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
宽度修饰符
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
左对齐
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
最小字段宽度
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
最大字段宽度
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
附注
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%20c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
否
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
无
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
左补充空格，如果分类名小于20个字符长。
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%-20c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
是
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
无
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
右补充空格，如果分类名小于20个字符长。
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%.30c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
无
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
无
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
如果分类名大于30个字符长，取前30个字符，去掉后面的。
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%20.30c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
否
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
如果分类名小于20个字符长，左补充空格。如果在20-30之间，按照原样输出。如果大于30个字符长，取前30个字符，去掉后面的。
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%-20.30c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
是
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
如果分类名小于20个字符长，右补充空格。如果在20-30之间，按照原样输出。如果大于30个字符长，取前30个字符，去掉后面的。
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
时间字符
\begin_inset CommandInset label
LatexCommand label
name "sub:时间字符"

\end_inset


\end_layout

\begin_layout Standard
这里是转换字符d支持的时间字符。
\end_layout

\begin_layout Standard
其中2个是zlog特有的，取自gettimeofday(2)
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features>
<column alignment="center" valignment="top" width="10text%">
<column alignment="center" valignment="top" width="60text%">
<column alignment="center" valignment="top" width="30text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
词
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
效果
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
例子
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%ms
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
毫秒，3位数字字符串
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
013
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%us
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
微秒，6位数字字符串
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
002323
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
其他的字符都是由strftime(2)生成的，在我的linux操作系统上支持的是：
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="42" columns="3">
<features islongtable="true">
<column alignment="center" valignment="top" width="10text%">
<column alignment="center" valignment="top" width="60text%">
<column alignment="center" valignment="top" width="30text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
字符
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
效果
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
例子
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
一星期中各天的缩写名，根据locale显示
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Wed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
一星期中各天的全名，根据locale显示
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Wednesday
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
缩写的月份名，根据locale显示
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mar
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
月份全名，根据locale显示
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
March
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
当地时间和日期的全表示， 根据locale显示
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Thu Feb 16 14:16:35 2012
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
世纪 (年/100)，2位的数字(SU)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%d
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
一个月中的某一天 (01-31)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
06
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
相当于%m/%d/%y.
 (呃，美国人专用，美国人要知道在别的国家%d/%m/%y 才是主流。也就是说在国际环境下这个格式容易造成误解，要少用) (SU)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
02/16/12
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%e
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
就像%d，一个月中的某一天，但是头上的0被替换成空格(SU)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
相当于%Y-%m-%d (ISO 8601日期格式)(C99) 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2012-02-16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The ISO 8601 week-based year (see NOTES) with century as a decimal number.
 The 4-digit year corre‐ sponding to the ISO week number (see %V).
 This has the same format and value as %Y, except that if the ISO week number
 belongs to the previous or next year, that year is used instead.
 (TZ)
\end_layout

\begin_layout Plain Layout
大意是采用%V定义的年，如果那年的前几天不算新年的第一周，就算上一年
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2012
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%g
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
相当于%G，就是不带世纪 (00-99).
 (TZ)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
相当于%b(SU)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Feb
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%H
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
小时，24小时表示(00-23)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
小时，12小时表示(01-12)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
02
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%j
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
一年中的各天(001-366)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
047
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%k
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
小时，24小时表示( 0-23)； 一位的前面为空格 (可和%H比较) (TZ)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%l
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
小时，12小时表示( 0-12)； 一位的前面为空格 (可和%比较)(TZ)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
月份(01-12)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
02
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%M
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
分钟(00-59)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
换行符 (SU) 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
n
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%p
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
"AM" 或 "PM"，根据当时的时间，根据locale显示相应的值，例如
\begin_inset Quotes erd
\end_inset

上午“、”下午“ 。 中午是"PM"，凌晨是"AM"
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PM
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
相当于%p不过是小写，根据locale显示相应的值 (GNU)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pm
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
时间+后缀AM或PM。在POSIX locale下相当于%I:%M:%S %p.
 (SU)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
03:11:54 PM
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
小时(24小时制):分钟 (%H:%M) (SU) 如果要带秒的，见%T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15:11
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Epoch以来的秒数，也就是从1970-01-01 00:00:00 UTC.
 (TZ)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1329376487
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
秒(00-60).
 (允许60是为了闰秒)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
54
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
制表符tab(SU)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
小时(24小时制):分钟:秒 (%H:%M:%S) (SU)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15:14:47
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
一周的天序号(1-7)，周一是1，另见%w (SU)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
一年中的星期序号(00-53)，周日是一周的开始，一年中第一个周日所在的周是第01周。另见%V和%W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
07
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%V
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ISO 8601星期序号(01-53)，01周是第一个至少有4天在新年的周。另见%U 和%W(SU)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
07
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
一周的天序号(0-6)，周日是0。另见%u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
一年中的星期序号(00-53)，周一是一周的开始，一年中第一个周一所在的周是第01周。另见%V和%W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
07
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
当前locale下的偏好日期
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
02/16/12
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
当前locale下的偏好时间
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15:14:47
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
不带世纪数目的年份(00-99)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%Y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
带世纪数目的年份
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2012
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%z
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
当前时区相对于GMT时间的偏移量。采用RFC 822-conformant来计算(话说我也不知道是啥) (using "%a, %d %b %Y
 %H:%M:%S %z").
 (GNU)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+0800
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%Z
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
时区名(如果有的话)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CST
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
一个百分号
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
规则(Rules)
\end_layout

\begin_layout Standard
这一节以[rules]开头。这个描述了日志是怎么被过滤、格式化以及被输出的。这节可以忽略不写，不过这样就没有日志输出了，嘿嘿。语法是：
\end_layout

\begin_layout LyX-Code
(category).(level)    (output), (file limitation,optional); (format name,
 optional)
\end_layout

\begin_layout Standard
当zlog_init()被调用的时候，所有规则都会被读到内存中。当zlog_get_category()被调用，规则就被被分配给分类（
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:分类匹配"

\end_inset

）。在实际写日志的时候，例如ZLOG_INFO()被调用的时候，就会比较这个INFO和各条规则的等级，来决定这条日志会不会通过这条规则输出。当zlog_relo
ad()被调用的时候，配置文件会被重新读入，包括所有的规则，并且重新计算分类对应的规则。
\end_layout

\begin_layout Subsection
级别匹配
\end_layout

\begin_layout Standard
zlog有6个默认的级别："DEBUG", "INFO", "NOTICE", "WARN", "ERROR"和"FATAL"。就像其他的日志函数库那样，
 aa.DEBUG意味着任何大于等于DEBUG级别的日志会被输出。当然还有其他的表达式。配置文件中的级别是大小写不敏感的。
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
表达式
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
含义
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
所有等级
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aa.debug
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
代码内等级>=debug
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aa.=debug
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
代码内等级==debug
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aa.!debug
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
代码内等级!=debug
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
用户可以自定义等级，详见
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:用户自定义等级"

\end_inset

。
\end_layout

\begin_layout Subsection
分类匹配
\begin_inset CommandInset label
LatexCommand label
name "sub:分类匹配"

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
分类必须由数字和字母组成，下划线
\begin_inset Quotes erd
\end_inset

_
\begin_inset Quotes erd
\end_inset

也算字母。
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features>
<column alignment="center" valignment="top" width="30text%">
<column alignment="center" valignment="top" width="20col%">
<column alignment="center" valignment="top" width="30col%">
<column alignment="center" valignment="top" width="20col%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
总结
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
配置文件规则分类
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
匹配的代码分类
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
不匹配的代码分类
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*匹配所有
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*.*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aa, aa_bb, aa_cc, xx, yy ...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NONE
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
以_结尾的分类匹配纲、目分类
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aa_.*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aa, aa_bb, aa_cc, aa_bb_cc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
xx, yy
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
不以_结尾的匹配目分类
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aa.*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aa
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aa_bb, aa_cc, aa_bb_cc
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
!匹配那些没有找到规则的分类
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
!.*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
xx
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aa(as it matches rules above)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
输出动作
\end_layout

\begin_layout Standard
目前zlog支持若干种输出，语法是：
\end_layout

\begin_layout Standard
[输出], [附加选项, 可选]; [format(格式)名, 可选]
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="30text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
动作
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
输出字段
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
附加选项
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
标准输出
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>stdout
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
无意义
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
标准错误输出
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>stderr
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
无意义
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
输出到syslog
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>syslog
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
syslog设施(facilitiy)：
\end_layout

\begin_layout Plain Layout
LOG_USER(default), LOG_LOCAL[0-7]
\end_layout

\begin_layout Plain Layout
必填
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
文件
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes erd
\end_inset

文件路径
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
文件大小个数限制 
\end_layout

\begin_layout Plain Layout
1000, 1k, 2M, 1G...
\end_layout

\begin_layout Plain Layout
3m*2, 4k*3...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
同步IO文件
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\begin_inset Quotes erd
\end_inset

文件路径
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
用户自定义输出
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
param
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
stdout, stderr, syslog
\end_layout

\begin_deeper
\begin_layout Standard
如表格描述，其中只有sylog的附加选项是有意义并必须写的。
\end_layout

\end_deeper
\begin_layout Itemize
文件
\end_layout

\begin_deeper
\begin_layout Itemize
文件路径
\end_layout

\begin_deeper
\begin_layout Standard
可以是相对路径或者绝对路径，被双引号"包含。转换格式串可以用在文件路径上。例如文件路径是 
\begin_inset Quotes eld
\end_inset

%E(HOME)/log/out.log
\begin_inset Quotes erd
\end_inset

，环境变量$HOME是/home/harry，那最后的输出文件是/home/harry/log/output.log。转换格式串详见 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:转换格式串"

\end_inset

。
\end_layout

\begin_layout Standard
zlog的文件功能极为强大，例如
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

/dev/console
\begin_inset Quotes erd
\end_inset

 #输出到控制台
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

/tmp/pipefile
\begin_inset Quotes erd
\end_inset

#输出到命名管道(FIFO)，必须在调用前由mkfifo(1)创建
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

/dev/null
\begin_inset Quotes erd
\end_inset

 #输出到NULL，也就是不输出
\end_layout

\end_deeper
\begin_layout Itemize
文件转档
\end_layout

\begin_deeper
\begin_layout Standard
控制文件的大小和个数。zlog根据这个字段来转档，当日志文件太大的时候。例如
\end_layout

\begin_layout LyX-Code
\begin_inset Quotes eld
\end_inset

%E(HOME)/log/out.log
\begin_inset Quotes erd
\end_inset

,1M*3
\end_layout

\begin_layout Standard
如果out.log被写到1M大，转档动作为：
\end_layout

\begin_layout LyX-Code
out.log -> out.log.1
\end_layout

\begin_layout LyX-Code
out.log(new create) 
\end_layout

\begin_layout Standard
如果新的日志文件再次被写满，转档动作为：
\end_layout

\begin_layout LyX-Code
out.log.1 -> out.log.2
\end_layout

\begin_layout LyX-Code
out.log -> out.log.1
\end_layout

\begin_layout LyX-Code
out.log(new create)
\end_layout

\begin_layout Standard
下一次的转档会把最旧的日志文件删除掉， *3意味着zlog会保留3个文件：
\end_layout

\begin_layout LyX-Code
unlink(out.log.2)
\end_layout

\begin_layout LyX-Code
out.log.1 -> out.log.2
\end_layout

\begin_layout LyX-Code
out.log -> out.log.1
\end_layout

\begin_layout LyX-Code
out.log(new create)
\end_layout

\begin_layout Standard
最旧的文件有最大的序列号。如果不写*3,则意味这一直转档下去，不会删除任何旧的日志。
\end_layout

\end_deeper
\begin_layout Itemize
同步IO文件
\begin_inset CommandInset label
LatexCommand label
name "ite:同步IO文件"

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
在文件路径前加上一个
\begin_inset Quotes erd
\end_inset

-
\begin_inset Quotes erd
\end_inset

就打开了同步IO选项。在打开文件(open)的时候，会以O_SYNC选项打开，这时候每次写日志操作都会等操作系统把数据写到硬盘后才返回。这个选项极为耗时：
\end_layout

\begin_layout LyX-Code
$ time ./test_press_zlog 100 1000
\end_layout

\begin_layout LyX-Code
real	0m0.732s
\end_layout

\begin_layout LyX-Code
user	0m1.030s
\end_layout

\begin_layout LyX-Code
sys	 0m1.080s
\end_layout

\begin_layout LyX-Code
$ time ./test_press_zlog 100 1000 # synchronous I/O open
\end_layout

\begin_layout LyX-Code
real	0m20.646s
\end_layout

\begin_layout LyX-Code
user	0m2.570s
\end_layout

\begin_layout LyX-Code
sys	 0m6.950s
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
格式名
\end_layout

\begin_deeper
\begin_layout Standard
是可选的，如果不写，用全局配置里面的默认格式：
\end_layout

\begin_layout LyX-Code
&default "%d(%F %T) %P [%p:%F:%L] %m%n"
\end_layout

\end_deeper
\begin_layout Itemize
用户自定义输出详见
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:用户自定义输出"

\end_inset


\end_layout

\begin_layout Section
配置文件工具
\end_layout

\begin_layout LyX-Code
$ zlog-chk-conf -h 
\end_layout

\begin_layout LyX-Code
Useage: zlog-chk-conf [conf files]...
 	
\end_layout

\begin_layout LyX-Code
-q,	suppress non-error message 	
\end_layout

\begin_layout LyX-Code
-h,	show help message
\end_layout

\begin_layout Standard
zlog-chk-conf 尝试读取配置文件，检查语法，然后往屏幕上输出这些配置文件是否正确。我建议每次创建或者改动一个配置文件之后都用一下这个工具。输出可能是
这样：
\end_layout

\begin_layout LyX-Code
$ ./zlog-chk-conf zlog.conf
\end_layout

\begin_layout LyX-Code
03-08 15:35:44 ERROR (10595:rule.c:391) sscanf [aaa] fail, category or level
 is null 
\end_layout

\begin_layout LyX-Code
03-08 15:35:44 ERROR (10595:conf.c:155) zlog_rule_new fail [aaa] 
\end_layout

\begin_layout LyX-Code
03-08 15:35:44 ERROR (10595:conf.c:258) parse configure file[zlog.conf] line[126]
 fail 
\end_layout

\begin_layout LyX-Code
03-08 15:35:44 ERROR (10595:conf.c:306) zlog_conf_read_config fail 
\end_layout

\begin_layout LyX-Code
03-08 15:35:44 ERROR (10595:conf.c:366) zlog_conf_build fail 
\end_layout

\begin_layout LyX-Code
03-08 15:35:44 ERROR (10595:zlog.c:66) conf_file[zlog.conf], init conf fail
 
\end_layout

\begin_layout LyX-Code
03-08 15:35:44 ERROR (10595:zlog.c:131) zlog_init_inner[zlog.conf] fail
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
---[zlog.conf] syntax error, see error message above
\end_layout

\begin_layout Standard
这个告诉你配置文件zlog.conf的126行，是错的。第一行进一步告诉你[aaa]不是一条正确的规则。
\end_layout

\begin_layout Standard
zlog-chk-conf可以同时分析多个配置文件，举例：
\end_layout

\begin_layout LyX-Code
$ zlog-chk-conf zlog.conf ylog.conf 
\end_layout

\begin_layout LyX-Code
--[zlog.conf] syntax right 
\end_layout

\begin_layout LyX-Code
--[ylog.conf] syntax right 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Chapter
zlog接口(API)
\end_layout

\begin_layout Standard
zlog的所有函数都是线程安全的，使用的时候只需要
\end_layout

\begin_layout LyX-Code
#include 
\begin_inset Quotes eld
\end_inset

zlog.h
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Section
初始化和清理
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
总览
\end_layout

\begin_deeper
\begin_layout LyX-Code
int zlog_init(char *
\bar under
confpath
\bar default
);
\end_layout

\begin_layout LyX-Code
int zlog_reload(char *
\bar under
confpath
\bar default
);
\end_layout

\begin_layout LyX-Code
void zlog_fini(void);
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00.00.0000
描述
\end_layout

\begin_deeper
\begin_layout Standard
zlog_init()从配置文件
\bar under
confpath
\bar default
中读取配置信息到内存。如果
\bar under
confpath
\bar default
为NULL，会寻找环境变量ZLOG_CONF_PATH的值作为配置文件名。如果环境变量ZLOG_CONF_PATH也没有，所有日志以内置格式写到标准输出上。每个
进程只有第一次调用zlog_init()是有效的，后面的多余调用都会失败并不做任何事情。 
\end_layout

\begin_layout Standard
zlog_reload()从
\bar under
confpath
\bar default
重载配置，并根据这个配置文件来重计算内部的分类规则匹配、重建每个线程的缓存、并设置原有的用户自定义输出函数。可以在配置文件发生改变后调用这个函数。这个函数使用次
数不限。如果
\bar under
confpath
\bar default
为NULL，会重载上一次zlog_init()或者zlog_reload()使用的配置文件。如果zlog_reload()失败，上一次的配置依然有效。所以zlo
g_reload()具有原子性。
\end_layout

\begin_layout Standard
zlog_fini()清理所有zlog API申请的内存，关闭它们打开的文件。使用次数不限。
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00.00.0000
返回值
\end_layout

\begin_deeper
\begin_layout Standard
如果成功，zlog_init()和zlog_reload()返回0。失败的话，zlog_init()和zlog_reload()返回-1。详细错误会被写在由环境
变量ZLOG_PROFILE_ERROR指定的错误日志里面。
\end_layout

\end_deeper
\begin_layout Section
分类(Category)操作
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
总览
\end_layout

\begin_deeper
\begin_layout LyX-Code
typedef struct zlog_category_s zlog_category_t;
\end_layout

\begin_layout LyX-Code
zlog_category_t *zlog_get_category(char *
\bar under
cname
\bar default
);
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00.00.0000
描述
\end_layout

\begin_deeper
\begin_layout Standard
zlog_get_category()从zlog的全局分类表里面找到分类，用于以后输出日志。如果没有的话，就建一个。然后它会遍历所有的规则，寻找和
\bar under
cname
\bar default
匹配的规则并绑定。
\end_layout

\begin_layout Standard
配置文件规则中的分类名匹配
\bar under
cname
\bar default
的规律描述如下：
\end_layout

\begin_layout Enumerate
* 匹配任意
\bar under
cname
\bar default
。
\end_layout

\begin_layout Enumerate
以下划线_结尾的分类名同时匹配本级分类和下级分类。例如aa_匹配aa, aa_, aa_bb, aa_bb_cc这几个
\bar under
cname
\bar default
。
\end_layout

\begin_layout Enumerate
不以下划线_结尾的分类名精确匹配
\bar under
cname
\bar default
。例如aa_bb匹配aa_bb这个
\bar under
cname
\bar default
。
\end_layout

\begin_layout Enumerate
! 匹配目前还没有规则的
\bar under
cname
\bar default
。
\end_layout

\begin_layout Standard
每个zlog_category_t *对应的规则，在zlog_reload()的时候会被自动重新计算。不用担心内存释放，zlog_fini()
 最后会清理一切。
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00.00.0000
返回值
\end_layout

\begin_deeper
\begin_layout Standard
如果成功，返回zlog_category_t的指针。如果失败，返回NULL。详细错误会被写在由环境变量ZLOG_PROFILE_ERROR指定的错误日志里面。
\end_layout

\end_deeper
\begin_layout Section
写日志函数及宏
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
总览
\end_layout

\begin_deeper
\begin_layout LyX-Code
void zlog(zlog_category_t * 
\bar under
category
\bar default
, 
\end_layout

\begin_layout LyX-Code
          const char *
\bar under
file
\bar default
, size_t 
\bar under
filelen
\bar default
,
\end_layout

\begin_layout LyX-Code
          const char *
\bar under
func
\bar default
, size_t 
\bar under
funclen
\bar default
, 
\end_layout

\begin_layout LyX-Code
          long 
\bar under
line
\bar default
, int 
\bar under
level
\bar default
,
\end_layout

\begin_layout LyX-Code
          const char *
\bar under
format
\bar default
, ...); 
\end_layout

\begin_layout LyX-Code
void vzlog(zlog_category_t * 
\bar under
category
\bar default
,
\end_layout

\begin_layout LyX-Code
          const char *
\bar under
file
\bar default
, size_t 
\bar under
filelen
\bar default
,
\end_layout

\begin_layout LyX-Code
          const char *
\bar under
func
\bar default
, size_t 
\bar under
funclen
\bar default
, 
\end_layout

\begin_layout LyX-Code
          long 
\bar under
line
\bar default
, int 
\bar under
level
\bar default
,
\end_layout

\begin_layout LyX-Code
          const char *
\bar under
format
\bar default
, va_list 
\bar under
args
\bar default
); 
\end_layout

\begin_layout LyX-Code
void hzlog(zlog_category_t * 
\bar under
category
\bar default
,
\end_layout

\begin_layout LyX-Code
          const char *
\bar under
file
\bar default
, size_t 
\bar under
filelen
\bar default
,
\end_layout

\begin_layout LyX-Code
          const char *
\bar under
func
\bar default
, size_t 
\bar under
funclen
\bar default
, 
\end_layout

\begin_layout LyX-Code
          long 
\bar under
line
\bar default
, int 
\bar under
level
\bar default
,
\end_layout

\begin_layout LyX-Code
          const void *
\bar under
buf
\bar default
, size_t 
\bar under
buflen
\bar default
); 
\end_layout

\begin_layout LyX-Code

\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00.00.0000
描述
\end_layout

\begin_deeper
\begin_layout Standard
这3个函数是实际写日志的函数，输入的数据对应于配置文件中的%m。
\bar under
category
\bar default
来自于调用zlog_get_category()。
\end_layout

\begin_layout Standard
zlog()和vzlog()根据format输出，就像printf(3)和vprintf(3)。
\end_layout

\begin_layout Standard
vzlog()相当于zlog()，只是它用一个va_list类型的参数args，而不是一堆类型不同的参数。vzlog() 内部使用了 va_copy
 宏，args的内容在vzlog()后保持不变，可以参考stdarg(3)。
\end_layout

\begin_layout Standard
hzlog()有点不一样，它产生下面这样的输出，长度为
\bar under
buf_len
\bar default
的内存
\bar under
buf
\bar default
以16进制的形式表示出来
\emph on
。
\end_layout

\begin_layout LyX-Code
hex_buf_len=[5365]  
\end_layout

\begin_layout LyX-Code
             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F      0123456789ABCDE
F
\end_layout

\begin_layout LyX-Code
0000000001   23 21 20 2f 62 69 6e 2f 62 61 73 68 0a 0a 23 20   #! /bin/bash..#
\end_layout

\begin_layout LyX-Code
0000000002   74 65 73 74 5f 68 65 78 20 2d 20 74 65 6d 70 6f   test_hex
 - tempo
\end_layout

\begin_layout LyX-Code
0000000003   72 61 72 79 20 77 72 61 70 70 65 72 20 73 63 72   rary wrapper
 scr
\end_layout

\begin_layout Standard
参数
\bar under
file
\bar default
和
\bar under
line
\bar default
填写为__FILE__和__LINE__这两个宏。这两个宏标识日志是在哪里发生的。参数
\bar under
func
\bar default
 填写为__func__或者__FUNCTION__，如果编译器支持的话，如果不支持，就填写为
\begin_inset Quotes eld
\end_inset

<unkown>
\begin_inset Quotes erd
\end_inset

。
\end_layout

\begin_layout Standard

\bar under
level
\bar default
是一个整数，应该是在下面几个里面取值。
\end_layout

\begin_layout LyX-Code
typedef enum {                 
\end_layout

\begin_deeper
\begin_layout LyX-Code
ZLOG_LEVEL_DEBUG = 20,
\end_layout

\begin_layout LyX-Code
ZLOG_LEVEL_INFO = 40,
\end_layout

\begin_layout LyX-Code
ZLOG_LEVEL_NOTICE = 60,
\end_layout

\begin_layout LyX-Code
ZLOG_LEVEL_WARN = 80,
\end_layout

\begin_layout LyX-Code
ZLOG_LEVEL_ERROR = 100,
\end_layout

\begin_layout LyX-Code
ZLOG_LEVEL_FATAL = 120
\end_layout

\end_deeper
\begin_layout LyX-Code
} zlog_level;
\end_layout

\begin_layout Standard
每个函数都有对应的宏，简单使用。例如：
\end_layout

\begin_layout LyX-Code
#define ZLOG_FATAL(cat, format, args...) 
\backslash
         
\end_layout

\begin_layout LyX-Code
zlog(cat, __FILE__, sizeof(__FILE__)-1, __func__, sizeof(__func__)-1, __LINE__,
 
\backslash
 
\end_layout

\begin_layout LyX-Code
ZLOG_LEVEL_FATAL, format, ##args) 
\end_layout

\begin_layout Standard
所有的宏列表：
\end_layout

\begin_layout LyX-Code
/* zlog macros */
\end_layout

\begin_layout LyX-Code
ZLOG_FATAL(cat, format, ...)
\end_layout

\begin_layout LyX-Code
ZLOG_ERROR(cat, format, ...)
\end_layout

\begin_layout LyX-Code
ZLOG_WARN(cat, format, ...)
\end_layout

\begin_layout LyX-Code
ZLOG_NOTICE(cat, format, ...)
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(cat, format, ...)
\end_layout

\begin_layout LyX-Code
ZLOG_DEBUG(cat, format, ...)
\end_layout

\begin_layout LyX-Code
/* vzlog macros */
\end_layout

\begin_layout LyX-Code
VZLOG_FATAL(cat, format, args)
\end_layout

\begin_layout LyX-Code
VZLOG_ERROR(cat, format, args)
\end_layout

\begin_layout LyX-Code
VZLOG_WARN(cat, format, args)
\end_layout

\begin_layout LyX-Code
VZLOG_NOTICE(cat, format, args)
\end_layout

\begin_layout LyX-Code
VZLOG_INFO(cat, format, args)
\end_layout

\begin_layout LyX-Code
VZLOG_DEBUG(cat, format, args)
\end_layout

\begin_layout LyX-Code
/* hzlog macros */
\end_layout

\begin_layout LyX-Code
HZLOG_FATAL(cat, buf, buf_len)
\end_layout

\begin_layout LyX-Code
HZLOG_ERROR(cat, buf, buf_len)
\end_layout

\begin_layout LyX-Code
HZLOG_WARN(cat, buf, buf_len)
\end_layout

\begin_layout LyX-Code
HZLOG_NOTICE(cat, buf, buf_len)
\end_layout

\begin_layout LyX-Code
HZLOG_INFO(cat, buf, buf_len)
\end_layout

\begin_layout LyX-Code
HZLOG_DEBUG(cat, buf, buf_len) 
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00.00.0000
返回值
\end_layout

\begin_deeper
\begin_layout Standard
这些函数不返回。如果有错误发生，详细错误会被写在由环境变量ZLOG_PROFILE_ERROR指定的错误日志里面。
\end_layout

\end_deeper
\begin_layout Section
MDC操作
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
总览
\end_layout

\begin_deeper
\begin_layout LyX-Code
int zlog_put_mdc(char *
\bar under
key
\bar default
, char *
\bar under
value
\bar default
);
\end_layout

\begin_layout LyX-Code
char *zlog_get_mdc(char *
\bar under
key
\bar default
);
\end_layout

\begin_layout LyX-Code
void zlog_remove_mdc(char *
\bar under
key
\bar default
);
\end_layout

\begin_layout LyX-Code
void zlog_clean_mdc(void);
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00.00.0000
描述
\end_layout

\begin_deeper
\begin_layout Standard
MDC(Mapped Diagnostic Context)是一个每线程拥有的键-值表，所以和分类没什么关系。
\end_layout

\begin_layout Standard

\bar under
key
\bar default
和
\bar under
value
\bar default
是字符串，长度不能超过MAXLEN_PATH(1024)。如果超过MAXLEN_PATH(1024)的话，会被截断。
\end_layout

\begin_layout Standard
记住这个表是和线程绑定的，每个线程有自己的表，所以在一个线程内的调用不会影响其他线程。
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00.00.0000
返回值
\end_layout

\begin_deeper
\begin_layout Standard
zlog_put_mdc()成功返回0，失败返回-1。zlog_get_mdc()成功返回value的指针，失败或者没有相应的key返回NULL。如果有错误发生
，详细错误会被写在由环境变量ZLOG_PROFILE_ERROR指定的错误日志里面。
\end_layout

\end_deeper
\begin_layout Section
dzlog接口
\begin_inset CommandInset label
LatexCommand label
name "sec:dzlog接口"

\end_inset


\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
总览
\end_layout

\begin_deeper
\begin_layout LyX-Code
int dzlog_init(char *
\bar under
confpath
\bar default
, char *
\bar under
cname
\bar default
);
\end_layout

\begin_layout LyX-Code
int dzlog_set_category(char *
\bar under
cname
\bar default
); 
\end_layout

\begin_layout LyX-Code
void dzlog(const char *
\bar under
file
\bar default
, size_t 
\bar under
filelen
\bar default
,
\end_layout

\begin_layout LyX-Code
           const char *
\bar under
func
\bar default
, size_t 
\bar under
funclen
\bar default
,
\end_layout

\begin_layout LyX-Code
           long 
\bar under
line
\bar default
, int 
\bar under
level
\bar default
,
\end_layout

\begin_layout LyX-Code
           const char *
\bar under
format
\bar default
, ...); 
\end_layout

\begin_layout LyX-Code
void vdzlog(const char *
\bar under
file
\bar default
, size_t 
\bar under
filelen
\bar default
,
\end_layout

\begin_layout LyX-Code
            const char *
\bar under
func
\bar default
, size_t 
\bar under
funclen
\bar default
,
\end_layout

\begin_layout LyX-Code
            long 
\bar under
line
\bar default
, int 
\bar under
level
\bar default
,
\end_layout

\begin_layout LyX-Code
            const char *
\bar under
format
\bar default
, va_list 
\bar under
args
\bar default
); 
\end_layout

\begin_layout LyX-Code
void hdzlog(const char *
\bar under
file
\bar default
, size_t 
\bar under
filelen
\bar default
,
\end_layout

\begin_layout LyX-Code
            const char *
\bar under
func
\bar default
, size_t 
\bar under
funclen
\bar default
,
\end_layout

\begin_layout LyX-Code
            long 
\bar under
line
\bar default
, int 
\bar under
level
\bar default
,
\end_layout

\begin_layout LyX-Code
            const void *
\bar under
buf
\bar default
, size_t 
\bar under
buflen
\bar default
);
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00.00.0000
描述
\end_layout

\begin_deeper
\begin_layout Standard
dzlog是忽略分类(zlog_category_t)的一组简单zlog接口。它采用内置的一个默认分类，这个分类置于锁的保护下。这些接口也是线程安全的。忽略了分
类，意味着用户不需要操心创建、存储、传输zlog_category_t类型的变量
\emph on
\noun on
。当然也可以在用
\emph default
\noun default
dzlog接口的同时用一般的zlog接口函数，这样会更爽。
\end_layout

\begin_layout Standard
dzlog_init()和zlog_init()一样做初始化，就是多需要一个默认分类名
\bar under
cname
\bar default
的参数。zlog_reload()、 zlog_fini() 可以和以前一样使用，用来刷新配置，或者清理。
\end_layout

\begin_layout Standard
dzlog_set_category()是用来改变默认分类用的。上一个分类会被替换成新的。同样不用担心内存释放的问题，zlog_fini()最后会清理。
\end_layout

\begin_layout Standard
dzlog的宏也定义在zlog.h里面。更简单的写法。
\end_layout

\begin_layout LyX-Code
DZLOG_FATAL(format, ...)
\end_layout

\begin_layout LyX-Code
DZLOG_ERROR(format, ...)
\end_layout

\begin_layout LyX-Code
DZLOG_WARN(format, ...)
\end_layout

\begin_layout LyX-Code
DZLOG_NOTICE(format, ...)
\end_layout

\begin_layout LyX-Code
DZLOG_INFO(format, ...)
\end_layout

\begin_layout LyX-Code
DZLOG_DEBUG(format, ...)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
VDZLOG_FATAL(format, args)
\end_layout

\begin_layout LyX-Code
VDZLOG_ERROR(format, args)
\end_layout

\begin_layout LyX-Code
VDZLOG_WARN(format, args)
\end_layout

\begin_layout LyX-Code
VDZLOG_NOTICE(format, args)
\end_layout

\begin_layout LyX-Code
VDZLOG_INFO(format, args)
\end_layout

\begin_layout LyX-Code
VDZLOG_DEBUG(format, args)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
HDZLOG_FATAL(buf, buf_len)
\end_layout

\begin_layout LyX-Code
HDZLOG_ERROR(buf, buf_len)
\end_layout

\begin_layout LyX-Code
HDZLOG_WARN(buf, buf_len)
\end_layout

\begin_layout LyX-Code
HDZLOG_NOTICE(buf, buf_len)
\end_layout

\begin_layout LyX-Code
HDZLOG_INFO(buf, buf_len)
\end_layout

\begin_layout LyX-Code
HDZLOG_DEBUG(buf, buf_len)
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00.00.0000
返回值
\end_layout

\begin_deeper
\begin_layout Standard
成功情况下dzlog_init()和dzlog_set_category()返回0。失败情况下dzlog_init()和 dzlog_set_category(
)返回-1。详细错误会被写在由环境变量ZLOG_PROFILE_ERROR指定的错误日志里面。
\end_layout

\end_deeper
\begin_layout Section
用户自定义输出
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
总览
\end_layout

\begin_deeper
\begin_layout LyX-Code
typedef int (*zlog_record_fn)(char *
\bar under
param
\bar default
, char *
\bar under
msg
\bar default
, size_t 
\bar under
msglen
\bar default
);
\end_layout

\begin_layout LyX-Code
int zlog_set_record(char *
\bar under
name
\bar default
, zlog_record_fn 
\bar under
record
\bar default
); 
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00.00.0000
描述
\end_layout

\begin_deeper
\begin_layout Standard
zlog允许用户自定义输出函数。输出函数需要绑定到某条特殊的规则上。这种规则的例子是：
\end_layout

\begin_layout LyX-Code
*.*     $name, param; simple
\end_layout

\begin_layout Standard
zlog_set_record()做绑定动作。规则中输出段有$
\bar under
name
\bar default
的，会被用来做用户自定义输出。输出函数为
\bar under
record
\bar default
。这个函数需要为zlog_record_fn的格式。 
\bar under
param
\bar default
来自规则的逗号后的字符串。
\bar under
msg
\bar default
和
\bar under
msglen
\bar default
 是zlog格式化后的日志信息和长度。
\end_layout

\begin_layout Standard
所有zlog_set_record()做的绑定在zlog_reload()使用后继续有效。
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00.00.0000
返回值
\end_layout

\begin_deeper
\begin_layout Standard
成功情况下zlog_set_record()返回0。失败情况下zlog_set_record()返回-1。详细错误会被写在由环境变量ZLOG_PROFILE_E
RROR指定的错误日志里面。
\end_layout

\end_deeper
\begin_layout Section
调试和诊断
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
总览
\end_layout

\begin_deeper
\begin_layout LyX-Code
void zlog_profile(void);
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00.00.0000
描述
\end_layout

\begin_deeper
\begin_layout Standard
环境变量ZLOG_PROFILE_ERROR指定zlog本身的错误日志。
\end_layout

\begin_layout Standard
环境变量ZLOG_PROFILE_DEBUG指定zlog本身的调试日志。
\end_layout

\begin_layout Standard
zlog_profile()打印所有内存中的配置信息到ZLOG_PROFILE_ERROR，在运行时。可以把这个和配置文件比较，看看有没有问题。
\end_layout

\end_deeper
\begin_layout Chapter
高阶使用
\end_layout

\begin_layout Section
MDC
\begin_inset CommandInset label
LatexCommand label
name "sec:MDC"

\end_inset


\end_layout

\begin_layout Standard
MDC是什么？在log4j里面解释为Mapped Diagnostic Context。听起来是个很复杂的技术，其实MDC就是一个键-值对表。一旦某次你设置了，
后面库可以帮你自动打印出来，或者成为文件名的一部分。让我们看一个例子，来自于$(top_builddir)/test/test_mdc.c.
\end_layout

\begin_layout LyX-Code
$ cat test_mdc.c
\end_layout

\begin_layout LyX-Code
#include <stdio.h>
\end_layout

\begin_layout LyX-Code
#include <stdlib.h>
\end_layout

\begin_layout LyX-Code
#include <sys/types.h>
\end_layout

\begin_layout LyX-Code
#include <unistd.h>
\end_layout

\begin_layout LyX-Code
#include <string.h>
\end_layout

\begin_layout LyX-Code
#include "zlog.h"
\end_layout

\begin_layout LyX-Code
int main(int argc, char** argv)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_deeper
\begin_layout LyX-Code
int rc;
\end_layout

\begin_layout LyX-Code
zlog_category_t *zc;
\end_layout

\begin_layout LyX-Code
rc = zlog_init("test_mdc.conf");
\end_layout

\begin_deeper
\begin_layout LyX-Code
if (rc) { 
\end_layout

\begin_layout LyX-Code
printf("init failed
\backslash
n");
\end_layout

\begin_layout LyX-Code
return -1;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
zc = zlog_get_category("my_cat");
\end_layout

\begin_layout LyX-Code
if (!zc) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
printf("get cat fail
\backslash
n");
\end_layout

\begin_layout LyX-Code
zlog_fini();
\end_layout

\begin_layout LyX-Code
return -2;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(zc, "1.hello, zlog");
\end_layout

\begin_layout LyX-Code
zlog_put_mdc("myname", "Zhang");
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(zc, "2.hello, zlog");
\end_layout

\begin_layout LyX-Code
zlog_put_mdc("myname", "Li");
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(zc, "3.hello, zlog"); 
\end_layout

\begin_layout LyX-Code
zlog_fini(); 
\end_layout

\begin_layout LyX-Code
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code
} 
\end_layout

\begin_layout Standard
配置文件
\end_layout

\begin_layout LyX-Code
$ cat test_mdc.conf
\end_layout

\begin_layout LyX-Code
[formats]
\end_layout

\begin_layout LyX-Code
mdc_format=     "%d(%F %X.%ms) %-6V (%c:%F:%L) [%M(myname)] - %m%n"
\end_layout

\begin_layout LyX-Code
[rules]
\end_layout

\begin_layout LyX-Code
*.*             >stdout; mdc_format
\end_layout

\begin_layout Standard
输出
\end_layout

\begin_layout LyX-Code
$ ./test_mdc
\end_layout

\begin_layout LyX-Code
2012-03-12 09:26:37.740 INFO   (my_cat:test_mdc.c:47) [] - 1.hello, zlog 
\end_layout

\begin_layout LyX-Code
2012-03-12 09:26:37.740 INFO   (my_cat:test_mdc.c:51) [Zhang] - 2.hello, zlog
 
\end_layout

\begin_layout LyX-Code
2012-03-12 09:26:37.740 INFO   (my_cat:test_mdc.c:55) [Li] - 3.hello, zlog
\end_layout

\begin_layout Standard
你可以看到zlog_put_mdc()在表里面设置键
\begin_inset Quotes eld
\end_inset

myname
\begin_inset Quotes erd
\end_inset

对应值
\begin_inset Quotes eld
\end_inset

Zhang
\begin_inset Quotes erd
\end_inset

，然后在配置文件里面%M(myname)指出了在日志的哪个位置需要把值打出来。第二次，键
\begin_inset Quotes eld
\end_inset

myname
\begin_inset Quotes erd
\end_inset

的值被覆盖写成
\begin_inset Quotes eld
\end_inset

Li
\begin_inset Quotes erd
\end_inset

，然后日志里面也有相应的变化。
\end_layout

\begin_layout Standard
MDC什么时候有用呢？往往在用户需要在同样的日志行为区分不同的业务数据的时候。比如说，c源代码是
\end_layout

\begin_layout LyX-Code
zlog_put_mdc(
\begin_inset Quotes eld
\end_inset

customer_name
\begin_inset Quotes erd
\end_inset

, get_customer_name_from_db() );
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(
\begin_inset Quotes eld
\end_inset

get in
\begin_inset Quotes erd
\end_inset

); 
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(
\begin_inset Quotes eld
\end_inset

pick product
\begin_inset Quotes erd
\end_inset

); 
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(
\begin_inset Quotes eld
\end_inset

pay
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(
\begin_inset Quotes eld
\end_inset

get out
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Standard
在配置文件里面是
\end_layout

\begin_layout LyX-Code
&format  
\begin_inset Quotes eld
\end_inset

%M(customer_name) %m%n
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
当程序同时处理两个用户的时候，打出来的日志可能是
\end_layout

\begin_layout LyX-Code
Zhang get in
\end_layout

\begin_layout LyX-Code
Li get in
\end_layout

\begin_layout LyX-Code
Zhang pick product
\end_layout

\begin_layout LyX-Code
Zhang pay
\end_layout

\begin_layout LyX-Code
Li pick product
\end_layout

\begin_layout LyX-Code
Li pay
\end_layout

\begin_layout LyX-Code
Zhang get out
\end_layout

\begin_layout LyX-Code
Li get out
\end_layout

\begin_layout Standard
这样，你就可以用grep命令把这两个用户的日志分开来了
\end_layout

\begin_layout LyX-Code
$ grep Zhang aa.log > Zhang.log
\end_layout

\begin_layout LyX-Code
$ grep Li aa.log >Li.log
\end_layout

\begin_layout Standard
或者，还有另外一条路，一开始在文件名里面做区分，看配置文件：
\end_layout

\begin_layout LyX-Code
*.* "mdc_%M(customer_name).log";
\end_layout

\begin_layout Standard
这就会产生3个日志文件。
\end_layout

\begin_layout LyX-Code
mdc_.log mdc_Zhang.log mdc_Li.log
\end_layout

\begin_layout Standard
这是一条近路，如果用户知道自己在干什么。
\end_layout

\begin_layout Standard
MDC是每个线程独有的，所以可以把一些线程专有的变量设置进去。如果单单为了区分线程，可以用转换字符里面的%t来搞定。
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Section
诊断zlog本身
\begin_inset CommandInset label
LatexCommand label
name "sec:诊断zlog本身"

\end_inset


\end_layout

\begin_layout Standard
OK，至今为止，我假定zlog库本身是不出毛病的。zlog帮助用户程序写日志，帮助程序员debug程序。但是如果zlog内部出错了呢？怎么知道错在哪里呢？其他的
程序可以用日志库来debug，但日志库自己怎么debug？答案很简单，zlog有自己的日志——诊断日志。这个日志通常是关闭的，可以通过环境变量来打开。
\end_layout

\begin_layout LyX-Code
$ export ZLOG_PROFILE_DEBUG=/tmp/zlog.debug.log
\end_layout

\begin_layout LyX-Code
$ export ZLOG_PROFILE_ERROR=/tmp/zlog.error.log
\end_layout

\begin_layout Standard
诊断日志只有两个级别debug和error。设置好环境变量后.
 再跑test_hello程序
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Hello-World-代码"

\end_inset

，然后debug日志为
\end_layout

\begin_layout LyX-Code
$ more zlog.debug.log 
\end_layout

\begin_layout LyX-Code
03-13 09:46:56 DEBUG (7503:zlog.c:115) ------zlog_init start, compile time[Mar
 13 2012 11:28:56]------ 
\end_layout

\begin_layout LyX-Code
03-13 09:46:56 DEBUG (7503:spec.c:825) spec:[0x7fdf96b7c010][%d(%F %T)][%F
 %T 29][] 
\end_layout

\begin_layout LyX-Code
03-13 09:46:56 DEBUG (7503:spec.c:825) spec:[0x7fdf96b52010][ ][ 0][] 
\end_layout

\begin_layout LyX-Code
......
\end_layout

\begin_layout LyX-Code
03-13 09:52:40 DEBUG (8139:zlog.c:291) ------zlog_fini end------
\end_layout

\begin_layout Standard
zlog.error.log日志没产生，因为没有错误发生。
\end_layout

\begin_layout Standard
你可以看出来，debug日志展示了zlog是怎么初始化还有清理的。不过在ZLOG_INFO()执行的时候没有日志打出来，这是为了效率。
\end_layout

\begin_layout Standard
如果zlog库有任何问题，都会打日志到ZLOG_PROFILE_ERROR所指向的错误日志。比如说，在ZLOG_INFO()上用一个错误的printf的语法：
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(zc, "%l", 1);
\end_layout

\begin_layout Standard
然后编译执行程序，ZLOG_PROFILE_ERROR的日志会是
\end_layout

\begin_layout LyX-Code
$ cat zlog.error.log 
\end_layout

\begin_layout LyX-Code
03-13 10:04:58 ERROR (10102:buf.c:189) vsnprintf fail, errno[0] 
\end_layout

\begin_layout LyX-Code
03-13 10:04:58 ERROR (10102:buf.c:191) nwrite[-1], size_left[1024], format[%l]
 
\end_layout

\begin_layout LyX-Code
03-13 10:04:58 ERROR (10102:spec.c:329) zlog_buf_vprintf maybe fail or overflow
 
\end_layout

\begin_layout LyX-Code
03-13 10:04:58 ERROR (10102:spec.c:467) a_spec->gen_buf fail 
\end_layout

\begin_layout LyX-Code
03-13 10:04:58 ERROR (10102:format.c:160) zlog_spec_gen_msg fail 
\end_layout

\begin_layout LyX-Code
03-13 10:04:58 ERROR (10102:rule.c:265) zlog_format_gen_msg fail 
\end_layout

\begin_layout LyX-Code
03-13 10:04:58 ERROR (10102:category.c:164) hzb_log_rule_output fail 
\end_layout

\begin_layout LyX-Code
03-13 10:04:58 ERROR (10102:zlog.c:632) zlog_output fail, srcfile[test_hello.c],
 srcline[41]
\end_layout

\begin_layout Standard
这样，用户就能知道为啥期待的输出没有产生，然后搞定这个问题。
\end_layout

\begin_layout Standard
运行时诊断会带来一定的性能损失。一般来说，我在生产环境把ZLOG_PROFILE_ERROR打开，ZLOG_PROFILE_DEBUG关闭。
\end_layout

\begin_layout Standard
还有另外一个办法来诊断zlog。我们都知道，zlog_init()会把配置信息读入内存。在整个写日志的过程中，这块内存保持不变。如果用户程序因为某种原因损坏了这
块内存，那么就会造成问题。还有可能是内存中的信息和配置文件的信息不匹配。所以我设计了一个函数，把内存的信息展现到ZLOG_PROFILE_ERROR指向的错误日
志。
\end_layout

\begin_layout Standard
代码见$(top_builddir)/test/test_profile.c
\end_layout

\begin_layout LyX-Code
$ cat test_profile.c
\end_layout

\begin_layout LyX-Code
#include <stdio.h>
\end_layout

\begin_layout LyX-Code
#include "zlog.h"
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
int main(int argc, char** argv)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_deeper
\begin_layout LyX-Code
int rc;
\end_layout

\begin_layout LyX-Code
rc = dzlog_init("test_profile.conf", "my_cat");
\end_layout

\begin_layout LyX-Code
if (rc) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code
printf("init failed
\backslash
n");
\end_layout

\begin_layout LyX-Code
return -1;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
DZLOG_INFO("hello, zlog");
\end_layout

\begin_layout LyX-Code
zlog_profile();
\end_layout

\begin_layout LyX-Code
zlog_fini(); 
\end_layout

\begin_layout LyX-Code
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code
} 
\end_layout

\begin_layout Standard
zlog_profile()就是这个函数。配置文件很简单。
\end_layout

\begin_layout LyX-Code
$ cat test_profile.conf 
\end_layout

\begin_layout LyX-Code
[formats] 
\end_layout

\begin_layout LyX-Code
simple = "%m%n"   
\end_layout

\begin_layout LyX-Code
[rules]
\end_layout

\begin_layout LyX-Code
my_cat.*                >stdout; simple
\end_layout

\begin_layout Standard
然后zlog.error.log会是
\end_layout

\begin_layout LyX-Code
$ cat /tmp/zlog.error.log
\end_layout

\begin_layout LyX-Code
06-01 11:21:26 WARN  (7063:zlog.c:783) ------zlog_profile start------ 
\end_layout

\begin_layout LyX-Code
06-01 11:21:26 WARN  (7063:zlog.c:784) init_flag:[1] 
\end_layout

\begin_layout LyX-Code
06-01 11:21:26 WARN  (7063:conf.c:75) -conf[0x2333010]- 
\end_layout

\begin_layout LyX-Code
06-01 11:21:26 WARN  (7063:conf.c:76) --global-- 
\end_layout

\begin_layout LyX-Code
06-01 11:21:26 WARN  (7063:conf.c:77) ---file[test_profile.conf],mtime[2012-06-01
 11:20:44]--- 
\end_layout

\begin_layout LyX-Code
06-01 11:21:26 WARN  (7063:conf.c:78) ---strict init[1]--- 
\end_layout

\begin_layout LyX-Code
06-01 11:21:26 WARN  (7063:conf.c:79) ---buffer min[1024]--- 
\end_layout

\begin_layout LyX-Code
06-01 11:21:26 WARN  (7063:conf.c:80) ---buffer max[2097152]--- 
\end_layout

\begin_layout LyX-Code
06-01 11:21:26 WARN  (7063:conf.c:82) ---default_format--- 
\end_layout

\begin_layout LyX-Code
06-01 11:21:26 WARN  (7063:format.c:48) ---format[0x235ef60][default = %d(%F
 %T) %V [%p:%F:%L] %m%n(0x233b810)]--- 
\end_layout

\begin_layout LyX-Code
06-01 11:21:26 WARN  (7063:conf.c:85) ---file perms[0600]--- 
\end_layout

\begin_layout LyX-Code
06-01 11:21:26 WARN  (7063:conf.c:87) ---rotate lock file[/tmp/zlog.lock]---
 
\end_layout

\begin_layout LyX-Code
06-01 11:21:26 WARN  (7063:rotater.c:48) --rotater[0x233b7d0][0x233b7d0,/tmp/zlog.
lock,4]-- 
\end_layout

\begin_layout LyX-Code
06-01 11:21:26 WARN  (7063:level_list.c:37) --level_list[0x2335490]-- 
\end_layout

\begin_layout LyX-Code
06-01 11:21:26 WARN  (7063:level.c:37) ---level[0x23355c0][0,*,*,1,6]---
 
\end_layout

\begin_layout LyX-Code
06-01 11:21:26 WARN  (7063:level.c:37) ---level[0x23375e0][20,DEBUG,debug,5,7]---
 
\end_layout

\begin_layout LyX-Code
06-01 11:21:26 WARN  (7063:level.c:37) ---level[0x2339600][40,INFO,info,4,6]---
 
\end_layout

\begin_layout LyX-Code
06-01 11:21:26 WARN  (7063:level.c:37) ---level[0x233b830][60,NOTICE,notice,6,5]-
-- 
\end_layout

\begin_layout LyX-Code
06-01 11:21:26 WARN  (7063:level.c:37) ---level[0x233d850][80,WARN,warn,4,4]---
 
\end_layout

\begin_layout LyX-Code
06-01 11:21:26 WARN  (7063:level.c:37) ---level[0x233fc80][100,ERROR,error,5,3]--
- 
\end_layout

\begin_layout Section
用户自定义等级
\begin_inset CommandInset label
LatexCommand label
name "sec:用户自定义等级"

\end_inset


\end_layout

\begin_layout Standard
这里我把用户自定义等级的几个步骤写下来。
\end_layout

\begin_layout Enumerate
在配置文件中定义新的等级
\end_layout

\begin_deeper
\begin_layout LyX-Code
$ cat $(top_builddir)/test/test_level.conf
\end_layout

\begin_layout LyX-Code
[global]
\end_layout

\begin_layout LyX-Code
default format  =               "%V %v %m%n"
\end_layout

\begin_layout LyX-Code
[levels]
\end_layout

\begin_layout LyX-Code
TRACE = 30, LOG_DEBUG
\end_layout

\begin_layout LyX-Code
[rules]
\end_layout

\begin_layout LyX-Code
my_cat.TRACE            >stdout;
\end_layout

\begin_layout Standard
内置的默认等级是(这些不需要写在配置文件里面)
\end_layout

\begin_layout LyX-Code
DEBUG = 20, LOG_DEBUG
\end_layout

\begin_layout LyX-Code
INFO = 40, LOG_INFO
\end_layout

\begin_layout LyX-Code
NOTICE = 60, LOG_NOTICE
\end_layout

\begin_layout LyX-Code
WARN = 80, LOG_WARNING
\end_layout

\begin_layout LyX-Code
ERROR = 100, LOG_ERR
\end_layout

\begin_layout LyX-Code
FATAL = 120, LOG_ALERT
\end_layout

\begin_layout LyX-Code
UNKNOWN = 254, LOG_ERR
\end_layout

\begin_layout Standard
这样在zlog看来，一个整数(30)还有一个等级字符串(TRACE)代表了等级。这个整数必须位于[1,253]之间，其他数字是非法的。数字越大代表越重要。现在T
RACE比DEBUG重要(30>20)，比INFO等级低(30<40)。在这样的定义后，TRACE就可以在下面的配置文件里面用了。例如这句话：
\end_layout

\begin_layout LyX-Code
my_cat.TRACE		>stdout; 
\end_layout

\begin_layout Standard
意味着等级>=TRACE的，包括INFO, NOTICE, WARN, ERROR, FATAL会被写到标准输出。
\end_layout

\begin_layout Standard
格式里面的转换字符
\begin_inset Quotes eld
\end_inset

%V
\begin_inset Quotes erd
\end_inset

会产生等级字符串的大写输出，
\begin_inset Quotes eld
\end_inset

%v
\begin_inset Quotes erd
\end_inset

会产生小写的等级字符串输出。
\end_layout

\begin_layout Standard
另外，在等级的定义里面，LOG_DEBUG是指当需要输出到syslog的时候，自定义的TRACE等级会以LOG_DEBUG输出到syslog。
\end_layout

\end_deeper
\begin_layout Enumerate
在源代码里面直接用新的等级是这么搞的
\end_layout

\begin_deeper
\begin_layout LyX-Code
zlog(cat, __FILE__, sizeof(__FILE__)-1, __func__, sizeof(__func__)-1,__LINE__,
 30, 
\begin_inset Quotes eld
\end_inset

test %d
\begin_inset Quotes erd
\end_inset

, 1);
\end_layout

\begin_layout Standard
为了简单使用，创建一个.h头文件
\end_layout

\begin_layout LyX-Code
$ cat $(top_builddir)/test/test_level.h
\end_layout

\begin_layout LyX-Code
#ifndef __test_level_h
\end_layout

\begin_layout LyX-Code
#define __test_level_h
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
#include "zlog.h"
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
enum {
\end_layout

\begin_deeper
\begin_layout LyX-Code
ZLOG_LEVEL_TRACE = 30,
\end_layout

\begin_layout LyX-Code
/* must equals conf file setting */ 
\end_layout

\end_deeper
\begin_layout LyX-Code
};
\end_layout

\begin_layout LyX-Code
#define ZLOG_TRACE(cat, format, ...) 
\backslash

\end_layout

\begin_layout LyX-Code
        zlog(cat, __FILE__, sizeof(__FILE__)-1, __func__, sizeof(__func__)-1,
 __LINE__, 
\backslash

\end_layout

\begin_layout LyX-Code
        ZLOG_LEVEL_TRACE, format, ## __VA_ARGS__) 
\end_layout

\begin_layout LyX-Code
#endif
\end_layout

\end_deeper
\begin_layout Enumerate
这样ZLOG_TRACE就能在.c文件里面用了
\end_layout

\begin_deeper
\begin_layout LyX-Code
$ cat $(top_builddir)/test/test_level.c
\end_layout

\begin_layout LyX-Code
#include <stdio.h> 
\end_layout

\begin_layout LyX-Code
#include "test_level.h"
\end_layout

\begin_layout LyX-Code
int main(int argc, char** argv)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_deeper
\begin_layout LyX-Code
int rc;
\end_layout

\begin_layout LyX-Code
zlog_category_t *zc;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
rc = zlog_init("test_level.conf");
\end_layout

\begin_layout LyX-Code
if (rc) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
printf("init failed
\backslash
n");
\end_layout

\begin_layout LyX-Code
return -1;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
zc = zlog_get_category("my_cat");
\end_layout

\begin_layout LyX-Code
if (!zc) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
printf("get cat fail
\backslash
n");
\end_layout

\begin_layout LyX-Code
zlog_fini();
\end_layout

\begin_layout LyX-Code
return -2;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
ZLOG_TRACE(zc, "hello, zlog - trace");
\end_layout

\begin_layout LyX-Code
ZLOG_DEBUG(zc, "hello, zlog - debug");
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(zc, "hello, zlog - info");
\end_layout

\begin_layout LyX-Code
zlog_fini(); 
\end_layout

\begin_layout LyX-Code
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code
} 
\end_layout

\end_deeper
\begin_layout Enumerate
最后我们能看到输出
\end_layout

\begin_deeper
\begin_layout LyX-Code
$ ./test_level
\end_layout

\begin_layout LyX-Code
TRACE trace hello, zlog - trace 
\end_layout

\begin_layout LyX-Code
INFO info hello, zlog - info 
\end_layout

\begin_layout Standard
正是我们所期待的，配置文件只允许>=TRACE等级的日志输出到屏幕上。
\begin_inset Quotes erd
\end_inset

%V
\begin_inset Quotes erd
\end_inset

和
\begin_inset Quotes eld
\end_inset

%v
\begin_inset Quotes erd
\end_inset

也显示了正确的结果。
\end_layout

\end_deeper
\begin_layout Section
用户自定义输出
\begin_inset CommandInset label
LatexCommand label
name "sec:用户自定义输出"

\end_inset


\end_layout

\begin_layout Standard
这里我把用户自定义输出的几个步骤写下来。
\end_layout

\begin_layout Enumerate
在配置文件里面定义规则
\end_layout

\begin_deeper
\begin_layout LyX-Code
$ cat test_record.conf
\end_layout

\begin_layout LyX-Code
[formats]
\end_layout

\begin_layout LyX-Code
simple = "%m%n"
\end_layout

\begin_layout LyX-Code
[rules]
\end_layout

\begin_layout LyX-Code
my_cat.*      $myoutput, myparam;simple
\end_layout

\end_deeper
\begin_layout Enumerate
绑定一个函数到$myoutput，并使用之
\end_layout

\begin_deeper
\begin_layout LyX-Code
#include <stdio.h>
\end_layout

\begin_layout LyX-Code
#include "zlog.h"
\end_layout

\begin_layout LyX-Code
int output(char *str2, char *msg, size_t msg_len)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_deeper
\begin_layout LyX-Code
printf("[mystd]:[%s][%s][%ld]
\backslash
n", str2, msg, (long)msg_len);
\end_layout

\begin_layout LyX-Code
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
int main(int argc, char** argv)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_deeper
\begin_layout LyX-Code
int rc;
\end_layout

\begin_layout LyX-Code
zlog_category_t *zc;
\end_layout

\begin_deeper
\begin_layout LyX-Code
rc = zlog_init("test_record.conf");
\end_layout

\begin_layout LyX-Code
if (rc) {
\end_layout

\begin_layout LyX-Code
printf("init failed
\backslash
n");
\end_layout

\begin_layout LyX-Code
return -1;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
zlog_set_record("myoutput", output);
\end_layout

\begin_layout LyX-Code
zc = zlog_get_category("my_cat");
\end_layout

\begin_layout LyX-Code
if (!zc) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
printf("get cat fail
\backslash
n");
\end_layout

\begin_layout LyX-Code
zlog_fini();
\end_layout

\begin_layout LyX-Code
return -2;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(zc, "hello, zlog");
\end_layout

\begin_layout LyX-Code
zlog_fini();
\end_layout

\begin_layout LyX-Code
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code
} 
\end_layout

\end_deeper
\begin_layout Enumerate
最后我们发现用户自定义输出的函数能用了！
\end_layout

\begin_deeper
\begin_layout LyX-Code
[mystd]:[myparam][hello, zlog
\end_layout

\begin_layout LyX-Code
][12] 
\end_layout

\begin_layout Standard
正如你所见，msglen是12，zlog生成的msg在最后有一个换行符。
\end_layout

\end_deeper
\end_body
\end_document
