#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\begin_preamble
\usepackage[cm-default]{fontspec}
\usepackage{xunicode}
\usepackage{xltxtra}
\setmainfont[ItalicFont=KaiTi]{YaHei Consolas Hybrid}
%\setmainfont[BoldFont=KaiTi,ItalicFont=KaiTi]{SimSun}
%\setsansfont[BoldFont=KaiTi]{KaiTi}
%\setmonofont{KaiTi}

%其他中文设置%
\XeTeXlinebreaklocale “zh”%中文断行
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt%左右弹性间距
\usepackage{indentfirst}%段落首行缩进
\setlength{\parindent}{2em}%缩进两个字符

%编号语言、样式设置%
\numberwithin{equation}{section}%设置公式按章节进行编号
\numberwithin{figure}{section}% 按章节编号
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\language english
\inputencoding utf8-plain
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "zlog Users Guide CN"
\pdf_author "Hardy Simpson"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "unicode=false"
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
zlog使用攻略
\end_layout

\begin_layout Author
难易 著
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
适用于 zlog v0.9
\end_layout

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
有问题，写邮件到
\begin_inset CommandInset href
LatexCommand href
name "HardySimpson1984@gmail.com"
target "HardySimpson1984@gmail.com"
type "mailto:"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
zlog是什么？
\end_layout

\begin_layout Standard
zlog是一个高性能、线程安全、灵活、概念清晰的纯C日志函数库。
\end_layout

\begin_layout Standard
事实上，在C的世界里面没有特别好的日志函数库（就像JAVA里面的的log4j，或者C++的log4cxx）。C程序员都喜欢用自己的轮子。printf就是个挺好的
轮子，但没办法通过配置改变日志的格式或者输出文件。syslog是个系统级别的轮子，不过速度慢，而且功能比较单调。
\end_layout

\begin_layout Standard
所以我写了zlog。
\end_layout

\begin_layout Standard
zlog在效率、功能、安全性上大大超过了log4c，并且是用c写成的，具有比较好的通用性。
\end_layout

\begin_layout Standard
zlog有这些特性：
\end_layout

\begin_layout Itemize
syslog风格的配置文件，易学易用
\end_layout

\begin_layout Itemize
可以灵活配置日志输出的格式，类似于log4j的pattern layout
\end_layout

\begin_layout Itemize
syslog分类模型，比log4j系列的继承模型更加清晰
\end_layout

\begin_layout Itemize
多种输出，包括动态文件、静态文件、stdout、stderr、syslog
\end_layout

\begin_layout Itemize
可以在运行时动态刷新配置，只需要调用函数zlog_reload()
\end_layout

\begin_layout Itemize
高性能，在我的笔记本上达到72'000条日志每秒, 大概是syslog(3)配合rsyslogd的200倍速度 
\end_layout

\begin_layout Itemize
用户可以自定义等级，无需改变库代码
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Define-new-level"

\end_inset


\end_layout

\begin_layout Itemize
多线程和多进程写同一个日志的情况下，安全转档（转档就是把太大的日志重命名）
\end_layout

\begin_layout Itemize
可以精确到微秒
\end_layout

\begin_layout Itemize
如果一个程序默认只用一个分类输出，zlog提供了简单的调用包装dzlog
\end_layout

\begin_layout Itemize
MDC，一个log4j风格的键-值对的表，可以扩展用户自定义的字段
\end_layout

\begin_layout Itemize
自诊断，可以在运行时输出zlog自己的日志和配置状态
\end_layout

\begin_layout Itemize
不依赖其他库，只要是个POSIX系统就成(当然还要一个C99兼容的vsnprintf)
\end_layout

\begin_layout Standard
相关链接：
\end_layout

\begin_layout Standard
软件下载：
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/downloads/HardySimpson/zlog/zlog-latest-stable.tar.gz"

\end_inset


\end_layout

\begin_layout Standard
上手指南：zlog-latest-stable.tar.gz包内doc目录下 GettingStart-CN.txt GettingStart-EN.txt
\end_layout

\begin_layout Standard
使用攻略：zlog-latest-stable.tar.gz包内doc目录下 UsersGuide-CN.pdf UsersGuide-EN.pdf
\end_layout

\begin_layout Standard
源代码：
\begin_inset CommandInset href
LatexCommand href
name "git@github.com:HardySimpson/zlog.git"
target "git@github.com:HardySimpson/zlog.git"

\end_inset


\end_layout

\begin_layout Standard
英文主页：
\begin_inset CommandInset href
LatexCommand href
target "http://hardysimpson.github.com/zlog"

\end_inset


\end_layout

\begin_layout Standard
中文主页：
\begin_inset CommandInset href
LatexCommand href
name "http://www.oschina.net/p/zlog"
target "http://www.oschina.net/p/zlog"

\end_inset


\end_layout

\begin_layout Standard
作者博客：
\begin_inset CommandInset href
LatexCommand href
name "http://my.oschina.net/HardySimpson/blog"
target "http://my.oschina.net/HardySimpson/blog"

\end_inset


\end_layout

\begin_layout Standard
邮箱：
\begin_inset CommandInset href
LatexCommand href
name "HardySimpson1984@gmail.com"
target "HardySimpson1984@gmail.com"
type "mailto:"

\end_inset


\end_layout

\begin_layout Section
zlog 1.0 发布说明
\end_layout

\begin_layout Enumerate
zlog是基于POSIX的。目前我手上有的环境只有AIX和linux。如果在其他的系统下（FreeBSD, NetBSD, OpenBSD, OpenSolar
is, Mac OS X...）有问题欢迎探讨
\end_layout

\begin_layout Enumerate
zlog使用了一个C99兼容的vsnprintf。也就是说如果缓存大小不足，vsnprintf将会返回目标字符串应有的长度（不包括'
\backslash
0')。如果在你的系统上vsnprintf不是这么运作的，zlog就不知道怎么扩大缓存。如果在目标缓存不够的时候vsnprintf返回-1，zlog就会认为这次
写入失败。幸运的是目前大多数c标准库符合C99标准。glibc 2.1,libc on AIX, libc on freebsd...都是好的，不过glibc2.0不是。
在这种情况下，用户需要自己来装一个C99兼容的vsnprintf，来crack这个函数库。我推荐
\begin_inset CommandInset href
LatexCommand href
name "ctrio"
target "http://sourceforge.net/projects/ctrio/"

\end_inset

, 或者
\begin_inset CommandInset href
LatexCommand href
name "C99-snprintf"
target "http://www.jhweiss.de/software/snprintf.html"

\end_inset

。只要改buf.c就行，祝好运！
\end_layout

\begin_layout Enumerate
zlog1.0和0.9不是兼容的。因为我增加了__func__，这样在C99情况下能打印函数名。我还改了配置文件的格式，对配置文件分节，这样看的清楚点。如果你是zl
og0.9的用户，想要升级到1.0，那就需要重新编译你的程序链接新的库（你的源代码倒不用改，因为几个输出日志的宏和0.9还是一样）
\end_layout

\begin_layout Chapter
zlog不是什么？
\end_layout

\begin_layout Standard
zlog的目标是成为一个简而精的日志函数库，她不会直接支持网络输出或者写入数据库，她不会直接支持日志内容的过滤和解析。
\end_layout

\begin_layout Standard
原因很明显，日志库是被应用程序调用的，所有花在日志库上的时间都是应用程序运行时间的一部分，而上面说的这些操作都很费时间，会拖慢应用程序的速度。这些事儿应该在别的
进程或者别的机器上做。
\end_layout

\begin_layout Standard
如果你需要这些特性，我建议使用rsyslog，一个系统级别的日志搜集、过滤、存储软件，当然这是单独的进程，不是应用程序的一部分。
\end_layout

\begin_layout Standard
目前我正在考虑怎么让zlog和rsyslog合适的对接，传统的syslog(3)行，但不够优雅。当然我也考虑让应用程序挂一些输出函数到zlog上。有什么好想法，
告诉我！
\end_layout

\begin_layout Chapter
Hello World
\end_layout

\begin_layout Section
编译和安装zlog
\end_layout

\begin_layout Standard
下载
\begin_inset CommandInset href
LatexCommand href
name "zlog-latest-stable.tar.gz"
target "https://github.com/downloads/HardySimpson/zlog/zlog-latest-stable.tar.gz"
type "file:"

\end_inset


\end_layout

\begin_layout LyX-Code
$ tar -zxvf zlog-latest-stable.tar.gz
\end_layout

\begin_layout LyX-Code
$ cd zlog-0.9.0/
\end_layout

\begin_layout LyX-Code
$ ./configure --prefix=[where u wanna install it] 
\backslash

\end_layout

\begin_layout LyX-Code
      --enable-test 
\end_layout

\begin_layout LyX-Code
$ make 
\end_layout

\begin_layout LyX-Code
$ sudo make install
\end_layout

\begin_layout Standard
--enable-test用了的话，测试程序会被编译。这些程序是很好的zlog的使用案例。
\end_layout

\begin_layout Itemize
对于开发者，如果你在别的目录而不是在源代码目录编译(平行编译，parallel building)，编译完之后要把源代码测试目录的配置文件复制过来。否则运行测试
程序会报错，找不到配置文件。
\end_layout

\begin_layout LyX-Code
$ tar -zxvf zlog-0.9.0.tar.gz
\end_layout

\begin_layout LyX-Code
$ mkdir build && cd build
\end_layout

\begin_layout LyX-Code
$ ../zlog-0.9.0/configure --prefix=[where u wanna install it] 
\backslash

\end_layout

\begin_layout LyX-Code
      --enable-test 
\end_layout

\begin_layout LyX-Code
$ cp ../zlog-0.9.0/test/*.conf ./test/
\end_layout

\begin_layout LyX-Code
$ cd test
\end_layout

\begin_layout LyX-Code
$ ./test_hello
\end_layout

\begin_layout LyX-Code
hello, zlog
\end_layout

\begin_layout Itemize
对于开发者，如果是从github上直接下载，那就不会有configure这个脚本，因为这个脚本是由auto tools从configure.ac等源文件生成的。这
时候你的环境上就需要有automake, autoconf等工具来生成configure
\end_layout

\begin_layout LyX-Code
$ git clone git@github.com:HardySimpson/zlog.git
\end_layout

\begin_layout Standard
或者从这个地址下载zip包 
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/HardySimpson/zlog/zipball/master"
type "file:"

\end_inset


\end_layout

\begin_layout Standard
解压后，执行命令来生成configure
\end_layout

\begin_layout LyX-Code
$ cd zlog
\end_layout

\begin_layout LyX-Code
$ ./autogen.sh
\end_layout

\begin_layout Standard
后面的步骤就和本节一开始描述的一样了。
\end_layout

\begin_layout Section
应用程序调用和链接zlog
\end_layout

\begin_layout Standard
应用程序使用zlog很简单，只要在C文件里面加一行。
\end_layout

\begin_layout LyX-Code
#include 
\begin_inset Quotes eld
\end_inset

zlog.h
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
如果你的系统有pkgconfig，可以在makefile里面这么写
\end_layout

\begin_layout LyX-Code
CFLAGS += $(shell pkg-config --cflags zlog)
\end_layout

\begin_layout LyX-Code
LDFLAGS += $(shell pkg-config --libs zlog)
\end_layout

\begin_layout Standard
如果没有的话，手工链接的命令是
\end_layout

\begin_layout LyX-Code
$ cc -c -o app.o app.c -I[where zlog.h is put, commonly /usr/local/include]
\end_layout

\begin_layout LyX-Code
$ cc -o app app.o -L[where libzlog.so is put, commonly /usr/local/lib] -lzlog
 -lpthread
\end_layout

\begin_layout Section
Hello World 代码
\begin_inset CommandInset label
LatexCommand label
name "sec:Hello-World-Example"

\end_inset


\end_layout

\begin_layout Standard
这些代码在$(top_builddir)/test/test_hello.c, test_hello.conf
\end_layout

\begin_layout Enumerate
写一个C文件：
\end_layout

\begin_deeper
\begin_layout LyX-Code
$ vi test_hello.c
\end_layout

\begin_layout LyX-Code
#include <stdio.h> 
\end_layout

\begin_layout LyX-Code
#include "zlog.h"
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
int main(int argc, char** argv)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_deeper
\begin_layout LyX-Code
int rc;
\end_layout

\begin_layout LyX-Code
zlog_category_t *c;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
rc = zlog_init("test_hello.conf");
\end_layout

\begin_layout LyX-Code
if (rc) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
printf("init failed
\backslash
n");
\end_layout

\begin_layout LyX-Code
return -1;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
c = zlog_get_category("my_cat");
\end_layout

\begin_layout LyX-Code
if (!my_cat) {
\end_layout

\begin_layout LyX-Code
printf("get cat fail
\backslash
n");
\end_layout

\begin_deeper
\begin_layout LyX-Code
zlog_fini();
\end_layout

\begin_layout LyX-Code
return -2;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
ZLOG_INFO(c, "hello, zlog");
\end_layout

\begin_layout LyX-Code
zlog_fini();
\end_layout

\begin_layout LyX-Code
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code
} 
\end_layout

\end_deeper
\begin_layout Enumerate
写一个配置文件，放在和test_hello.c同样的目录下:
\end_layout

\begin_deeper
\begin_layout LyX-Code
$ vi test_hello.conf
\end_layout

\begin_layout LyX-Code
&simple                 "%m%n"
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
my_cat.DEBUG            >stdout; simple
\end_layout

\end_deeper
\begin_layout Enumerate
编译、然后运行!
\end_layout

\begin_deeper
\begin_layout LyX-Code
$ cc -c -o test_hello.o test_hello.c -I/usr/local/include
\end_layout

\begin_layout LyX-Code
$ cc -o test_hello test_hello.o -L/usr/local/lib -lzlog
\end_layout

\begin_layout LyX-Code
$ ./test_hello
\end_layout

\begin_layout LyX-Code
hello, zlog
\end_layout

\end_deeper
\begin_layout Section
更简单的Hello World
\end_layout

\begin_layout Standard
这个例子在$(top_builddir)/test/test_default.c, test_default.conf.
 源代码是： 
\end_layout

\begin_layout LyX-Code
#include <stdio.h>
\end_layout

\begin_layout LyX-Code
#include "zlog.h"
\end_layout

\begin_layout LyX-Code
int main(int argc, char** argv)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_deeper
\begin_layout LyX-Code
int rc;
\end_layout

\begin_layout LyX-Code
rc = dzlog_init("test_default.conf", "my_cat");
\end_layout

\begin_layout LyX-Code
if (rc) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
printf("init failed
\backslash
n");
\end_layout

\begin_layout LyX-Code
return -1;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
DZLOG_INFO("hello, zlog");
\end_layout

\begin_layout LyX-Code
zlog_fini();
\end_layout

\begin_layout LyX-Code
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code
} 
\end_layout

\begin_layout Standard
配置文件是test_default.conf，和test_hello.conf一模一样，最后执行程序的输出也一样。区别在于这里用了dzlog API，内含一个默认的
zlog_category_t。详见
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:dzlog-API"

\end_inset

。
\end_layout

\begin_layout Chapter
配置文件
\end_layout

\begin_layout Standard
大部分的zlog的行为取决于配置文件：把日志打到哪里去，用什么格式，怎么转档。配置文件是zlog的黑话，我尽量把这个黑话设计的简单明了。
\end_layout

\begin_layout Section
全局设置
\end_layout

\begin_layout Standard
# 全局设置以@开头。全局设置可以不写，使用内置的默认值。语法：
\end_layout

\begin_layout Standard
@[键][n个空格或tab][值]
\end_layout

\begin_layout Standard
# 如果ignore_error_format_rule是true，zlog_init()将会忽略错误的format和rule。否则zlog_init()将会严
格的检查所有format和rule的语法 ，碰到错误的就返回-1。默认值：
\end_layout

\begin_layout LyX-Code
@ignore_error_format_rule    false
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
# zlog在堆上为每个线程申请缓存。buf_size_min是单个缓存的最小值。写日志的时候，如果日志长度大于缓存，缓存会自动扩充到buf_size_max，
 日志再长超过buf_size_max就会截断。如果 buf_size_max 是 0，意味着不限制缓存，每次扩充buf_size=2*buf_size。缓存大
小可以加上 KB, MB 或 GB这些单位。默认值：
\end_layout

\begin_layout LyX-Code
@buf_size_min           1024
\end_layout

\begin_layout LyX-Code
@buf_size_max           2MB
\end_layout

\begin_layout Standard
# rotate_lock_file是一个posix文件锁文件。用来在多进程情况下，保证日志安全转档。zlog会在zlog_init()时候创建这个文件。确认你
执行程序的用户有权限创建和读写这个文件。如果有多个用户需要转档同一个日志文件，确认这个锁文件对于多个用户都可读写。默认值：
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
@rotate_lock_file       /tmp/zlog.lock
\end_layout

\begin_layout Standard
# default_format是缺省的日志格式。内置的缺省格式会产生类似这样的输出：
\end_layout

\begin_layout LyX-Code
2012-02-14 17:03:12 INFO [3758:test_hello.c:39] hello, zlog
\end_layout

\begin_layout Standard
可以把缺省格式设成你喜欢的样子，默认值：
\end_layout

\begin_layout LyX-Code
@default_format "%d(%F %T) %V [%p:%F:%L] %m%n"
\end_layout

\begin_layout Standard
# 用户自定义级别
\end_layout

\begin_layout Standard
zlog内置的级别是：
\end_layout

\begin_layout LyX-Code
@level               DEBUG = 20, LOG_DEBUG
\end_layout

\begin_layout LyX-Code
@level               INFO = 40, LOG_INFO
\end_layout

\begin_layout LyX-Code
@level               NOTICE = 60, LOG_NOTICE
\end_layout

\begin_layout LyX-Code
@level               WARN = 80, LOG_WARNING
\end_layout

\begin_layout LyX-Code
@level               ERROR = 100, LOG_ERR
\end_layout

\begin_layout LyX-Code
@level               FATAL = 120, LOG_ALERT
\end_layout

\begin_layout LyX-Code
@level               UNKNOWN = 254, LOG_ERR
\end_layout

\begin_layout Standard
语法：
\end_layout

\begin_layout Standard
@level[n个空格或tab][级别的字符串] = [级别数值][syslog级别, 可选]
\end_layout

\begin_layout Standard
级别数值要在 [1,253]内, 越大代表越重要。syslog级别是可选，不设的话默认是LOG_DEBUG。详见
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Define-new-level"

\end_inset

。
\end_layout

\begin_layout Section
分类(Category)、规则(Rule)和格式(Format)
\end_layout

\begin_layout Standard
C代码片段是：
\end_layout

\begin_layout LyX-Code
zlog_init("test_hello.conf");
\end_layout

\begin_layout LyX-Code
/* read conf file to memory */
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
c = zlog_get_category("my_cat");
\end_layout

\begin_layout LyX-Code
/* match 
\begin_inset Quotes eld
\end_inset

my_cat
\begin_inset Quotes erd
\end_inset

 to c */
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(c, "hello, zlog");
\end_layout

\begin_layout LyX-Code
/* logging action 
\begin_inset Quotes eld
\end_inset

hello, zlog
\begin_inset Quotes erd
\end_inset

 which bonds to c */
\end_layout

\begin_layout Standard
以及配置文件是：
\end_layout

\begin_layout LyX-Code
&simple                 "%m%n"           
\end_layout

\begin_layout LyX-Code
# format, begein with a &
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
my_cat.DEBUG             >stdout; simple
\end_layout

\begin_layout LyX-Code
# rule, all my_cat's log and level bigger than debug
\end_layout

\begin_layout LyX-Code
# output to standard output, use simple format decribed above.
\end_layout

\begin_layout Standard
最后的输出是：
\end_layout

\begin_layout LyX-Code
hello, zlog
\end_layout

\begin_layout Standard
分类(Category)用于区分不同的输入。代码中的
\emph on
分类变量
\emph default
的名字是一个字符串，在一个程序里面可以通过获取不同的分类名的category用来后面输出不同分类的日志，用于不同的目的。
\end_layout

\begin_layout Standard
格式(Format)是用来描述输出日志的格式，比如是否有带有时间戳， 是否包含文件位置信息等，上面的例子里面的格式simple就是简单的用户输入的信息+换行符。
\end_layout

\begin_layout Standard
规则(Rule)则是把分类、级别、输出文件、格式组合起来，决定一条代码中的日志是否输出，输出到哪里，以什么格式输出。简单而言，规则里面的
\emph on
分类字符串
\emph default
和代码里面的
\emph on
分类变量
\emph default
的名字一样就匹配，当然还有其他情况，见后面的
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:category-match"

\end_inset

。
\end_layout

\begin_layout Standard
所以，当程序运行这样一条语句的时候
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(c, "hello, zlog");
\end_layout

\begin_layout Standard
首先zlog库会找到c对应的分类的名字，然后看这个分类在配置文件中有那几条规则是匹配的，目前这个分类拥有的规则是
\end_layout

\begin_layout LyX-Code
my_cat.DEBUG             >stdout; simple
\end_layout

\begin_layout Standard
然后检查目前的日志级别是否满足来决定是否输出，因为INFO级别大于DEBUG，所以这条日志要被输出。并且根据这条规则，会被输出到stdout(标准输出)，并且输
出的格式是simple这个格式，也就是配置文件中这条决定的
\end_layout

\begin_layout LyX-Code
&simple                 "%m%n" 
\end_layout

\begin_layout Standard
最后在屏幕上输出
\end_layout

\begin_layout LyX-Code
hello, zlog
\end_layout

\begin_layout Standard
这就是整个过程。用户只需要写自己的消息，最后日志发送到哪里，以什么格式，都由zlog库来完成。
\end_layout

\begin_layout Standard

\emph on
分类变量
\emph default
和规则(rule)是松耦合的。如果有两条上面的规则，则ZLOG_INFO(c, "hello, zlog")会打印出两条
\begin_inset Quotes eld
\end_inset

hello, zlog
\begin_inset Quotes erd
\end_inset

。如果规则被误写为
\begin_inset Quotes eld
\end_inset

my_ca.debug >stdout; simple
\begin_inset Quotes erd
\end_inset

，没有东西会被输出。 松耦合是同时易错并灵活的。当然，zlog有办法弥补这一点，见
\begin_inset CommandInset ref
LatexCommand ref
reference "category-nomatch"

\end_inset

。
\end_layout

\begin_layout Standard
规则(rule)和格式(format)是紧耦合的，如果规则(rule)使用了一条不存在的格式(format)，zlog_init()会失败，除非在配置文件中设置
\begin_inset Quotes eld
\end_inset

@ignore_error_format_rule false
\begin_inset Quotes erd
\end_inset

。
\end_layout

\begin_layout Standard
格式(format)的语法是：
\end_layout

\begin_layout Standard
&[格式名][n个空格或tab]"[转换格式串]"
\end_layout

\begin_layout Standard
规则的语法是：
\end_layout

\begin_layout Standard
[选择器][n个空格或tab][输出器]
\end_layout

\begin_layout Standard
[选择器] = [分类字符串].[级别]
\end_layout

\begin_layout Standard
[输出器] = [输出], [文件大小个数限制, 可选]; [format(格式)名, 可选]
\end_layout

\begin_layout Section
选择输入
\begin_inset CommandInset label
LatexCommand label
name "sec:Select-Input"

\end_inset


\end_layout

\begin_layout Standard
一条日志最终会不会被zlog打印，取决于源代码中的
\emph on
分类变量
\emph default
、级别和配置文件中的
\emph on
分类字符串
\emph default
、级别是否匹配。
\end_layout

\begin_layout Standard
[选择器] = [分类名].[级别]
\end_layout

\begin_layout Subsection
级别匹配
\end_layout

\begin_layout Standard
zlog有6个默认的级别："DEBUG", "INFO", "NOTICE", "WARN", "ERROR"和"FATAL"。就像其他的日志函数库那样，
 aa.DEBUG意味着任何大于等于DEBUG级别的日志会被输出。当然还有其他的表达式。配置文件中的级别是大小写不敏感的。
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
表达式
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
含义
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
所有等级
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aa.debug
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
代码内等级>=debug
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aa.=debug
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
代码内等级==debug
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aa.!debug
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
代码内等级!=debug
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
用户可以自定义等级，详见
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Define-new-level"

\end_inset

。
\end_layout

\begin_layout Subsection
分类匹配
\begin_inset CommandInset label
LatexCommand label
name "sub:category-match"

\end_inset


\end_layout

\begin_layout Standard
终于到这里了，zlog的代码
\emph on
分类变量
\emph default
和配置文件中规则的
\emph on
分类字符串
\emph default
的匹配是比较特殊的。表面看起来和log4j差不多，但内涵不一样。我称之为纲目分类模型。
\end_layout

\begin_layout Standard
在log4j里面有父logger和子logger。比如说一个log4j的配置文件是这样。
\end_layout

\begin_layout LyX-Code
log4j.logger.aa=ERROR, A1
\end_layout

\begin_layout LyX-Code
log4j.logger.aa.bb=
\end_layout

\begin_layout LyX-Code
log4j.logger.aa.cc=INFO
\end_layout

\begin_layout Standard
aa是一个父logger。aa.bb和aa.cc是aa的子logger。
\end_layout

\begin_layout Standard
aa.bb继承了aa's等级和输出(appender)，等级是ERROR输出是A1。
\end_layout

\begin_layout Standard
aa.cc继承并覆盖了aa的级别。所以aa.cc的等级是INFO输出还是A1。
\end_layout

\begin_layout Standard
需求1：如果我现在想把所有的aa的日志，所有的级别，输出到一个特别的文件里面去，并保持原来的aa.bb、aa.cc的输出不变，如何实现？
\end_layout

\begin_layout Standard
需求2：假设我动了aa.bb的代码，想在生产上把aa.bb的所有日志，从DEBUG级别开始输出到某个aa.bb.debug.log，而保持aa的ERROR以上级别的日志不
动（方便运维人员不改变他们的习惯，直接看原来的日志）
\end_layout

\begin_layout Standard
log4j将会如何实现这些需求？很困难，也许要在appender上引入阈值(threshold)，或者引入子logger不继承父logger的选项。子logge
r可以自己指定一个等级，或者从父logger那里继承一个。但说到底，log4j的logger必须有且只能有一个等级，等级和logger是绑定的。
\end_layout

\begin_layout Standard
zlog将会如何实现这些需求？首先，zlog继承了syslog配置文件的思想，一个分类的不同等级可以同时存在不同的规则内。这就让过滤同一分类的不同等级的日志到不
同日志文件成为可能。
\end_layout

\begin_layout LyX-Code
aa.debug         
\begin_inset Quotes eld
\end_inset

/var/log/aa.debug.log
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
aa.=notice       
\begin_inset Quotes eld
\end_inset

/var/log/aa.notice.log
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
是不是觉得自由了很多？
\end_layout

\begin_layout Standard
其次，在zlog里面，所有的规则之间都是独立的，没有父子关系。纲目分类的关系表现在
\emph on
分类字符串
\emph default
中间的下划线。举例：
\end_layout

\begin_layout LyX-Code
#rule 1
\end_layout

\begin_layout LyX-Code
aa_bb.DEBUG         
\begin_inset Quotes eld
\end_inset

/var/log/aa_bb.log
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
#rule 2
\end_layout

\begin_layout LyX-Code
aa_cc.INFO          
\begin_inset Quotes eld
\end_inset

/var/log/aa_cc.log
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
#rule 3
\end_layout

\begin_layout LyX-Code
aa_.ERROR           
\begin_inset Quotes eld
\end_inset

/var/log/aa_error.log
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
#rule 4
\end_layout

\begin_layout LyX-Code
aa.*                
\begin_inset Quotes eld
\end_inset

/var/log/aa.log
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
没有继承，只有4条独立的规则
\end_layout

\begin_layout Standard
如果代码里面的分类名是
\begin_inset Quotes eld
\end_inset

aa_bb
\begin_inset Quotes erd
\end_inset

。代码就像这样：
\end_layout

\begin_layout LyX-Code
category_t ab;
\end_layout

\begin_layout LyX-Code
ab = zlog_get_category(
\begin_inset Quotes eld
\end_inset

aa_bb
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout LyX-Code
ZLOG_DEBUG(ab, 
\begin_inset Quotes eld
\end_inset

ab's debug
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout LyX-Code
ZLOG_ERROR(ab, 
\begin_inset Quotes eld
\end_inset

ab's error
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Standard
配置中，rule 1的
\emph on
分类字符串
\emph default

\begin_inset Quotes erd
\end_inset

aa_bb
\begin_inset Quotes erd
\end_inset

和rule 3的
\emph on
分类字符串
\emph default

\begin_inset Quotes erd
\end_inset

aa_
\begin_inset Quotes erd
\end_inset

，与代码中的名字为
\begin_inset Quotes erd
\end_inset

aa_bb
\begin_inset Quotes erd
\end_inset

的
\emph on
分类变量
\emph default
是匹配的。于是代码中属于aa_bb
\emph on
分类变量
\emph default
、>=DEBUG日志输出到aa_bb.log，属于aa_bb
\emph on
分类变量
\emph default
、>=ERROR会被输出到 aa_error.log。ERROR等级的日志会被同时写在两个文件里面。不过rule 4的变量字符串是
\begin_inset Quotes erd
\end_inset

aa
\begin_inset Quotes erd
\end_inset

，它不匹配
\emph on
分类变量
\emph default

\begin_inset Quotes erd
\end_inset

aa_bb
\begin_inset Quotes erd
\end_inset

，它精确匹配拥有
\begin_inset Quotes eld
\end_inset

aa
\begin_inset Quotes erd
\end_inset

名字的
\emph on
分类变量
\emph default
。
\end_layout

\begin_layout Standard
这就是纲目分类模型。规则和规则之间是分开的。一个代码
\emph on
分类变量
\emph default
可以匹配多个规则
\emph on
分类字符串
\emph default
，一个规则可以属于多个代码
\emph on
分类变量
\emph default
。规则中的纲
\emph on
分类字符串
\emph default
(以下划线结尾的)匹配代码中的目
\emph on
分类变量
\emph default
，纲
\emph on
分类字符串
\emph default
的范围包括了了目
\emph on
分类字符串
\emph default
。这样，用户可以选择任意范围的纲目
\emph on
分类字符串
\emph default
来输出，而不影响其他规则的行为。
\end_layout

\begin_layout Standard
事实上，在zlog_get_category()被调用的时候，
\emph on
并不
\emph default
保证代码
\emph on
分类变量
\emph default
一定有相匹配的规则
\emph on
分类字符串
\emph default
。分类变量可以有很多与之匹配的规则，也有可能一条都没有，这取决于配置文件是怎么写的。当配置文件改变并调用zlog_reload()后，代码
\emph on
分类变量
\emph default
和规则
\emph on
分类字符串
\emph default
的匹配会被重新计算。根据上面所说的匹配方式，每个
\emph on
分类变量
\emph default
都会从新的配置文件里面找到自己的新规则。
\end_layout

\begin_layout Standard
也就是说，在zlog里面，多输出是由多条规则来实现的，而不是log4j的多个appender。一条规则代表程序员对于某种分类和等级的日志的输出需求。没有必要指定
某个分类必须为什么等级。分类、等级、输出这3者可以自由搭配，完全解耦，这样就带来了极大的灵活性。
\end_layout

\begin_layout Standard
必须感谢unix系统syslog的设计者。从思想上来说，zlog只是在他们的基础上增加了一点点的改动来匹配纲目分类，但灵活性远超java系列的绑定思想。也许lo
g4j的设计者被继承这两个字晃花了眼，以为继承就是解决一切问题的灵丹妙药……
\end_layout

\begin_layout Subsection
分类没有匹配规则的问题
\begin_inset CommandInset label
LatexCommand label
name "category-nomatch"

\end_inset


\end_layout

\begin_layout Standard
分类没有匹配规则的问题，可以通过垃圾箱规则来弥补。规则的分类名为"!"的就是垃圾箱规则，匹配那些找不到规则的代码分类。例如zlog_get_category(
\begin_inset Quotes eld
\end_inset

xx
\begin_inset Quotes erd
\end_inset

)遍历所有规则，但没有发现匹配的规则，然后有一个规则的分类名是'!'，于是匹配这条垃圾箱规则。垃圾箱规则是唯一的，只有最后一条带"!"的规则才是有用的。用户可用
这个表达式，在运行的时候把误写的都找出来。这个规则可以这么写：
\end_layout

\begin_layout LyX-Code
!.*                
\begin_inset Quotes eld
\end_inset

/var/log/zlog.mismatch.log
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
用表格来总结分类匹配
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features>
<column alignment="center" valignment="top" width="30text%">
<column alignment="center" valignment="top" width="20col%">
<column alignment="center" valignment="top" width="30col%">
<column alignment="center" valignment="top" width="20col%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
总结
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
配置文件规则分类
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
匹配的代码分类
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
不匹配的代码分类
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*匹配所有
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*.*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aa, aa_bb, aa_cc, xx, yy ...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NONE
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
以_结尾的分类匹配纲、目分类
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aa_.*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aa, aa_bb, aa_cc, aa_bb_cc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
xx, yy
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
不以_结尾的匹配目分类
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aa.*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aa
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aa_bb, aa_cc, aa_bb_cc
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
!匹配那些没有找到规则的分类
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
!.*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
xx
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aa(as it matches rules above)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
输出动作
\end_layout

\begin_layout Standard
目前zlog支持4种输出，语法是：
\end_layout

\begin_layout Standard
[输出器] = [输出], [文件大小个数限制, 可选]; [format(格式)名, 可选]
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="30text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
动作
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
输出字段
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
文件限制字段
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
标准输出
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>stdout
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
无意义
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
标准错误输出
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>stderr
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
无意义
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
输出到syslog
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>syslog
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
syslog设施(facilitiy)：
\end_layout

\begin_layout Plain Layout
LOG_USER(default), LOG_LOCAL[0-7]
\end_layout

\begin_layout Plain Layout
必填
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
文件
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

文件路径
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
文件大小个数限制 
\end_layout

\begin_layout Plain Layout
1000, 1k, 2M, 1G...
\end_layout

\begin_layout Plain Layout
3m*2, 4k*3...
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\emph on
文件路径 
\emph default
可以是相对路径或者绝对路径，被双引号"包含。
\emph on
转换格式串
\emph default
可以用在文件路径上。例如文件路径是 
\begin_inset Quotes eld
\end_inset

%E(HOME)/log/out.log
\begin_inset Quotes erd
\end_inset

，环境变量$HOME是/home/harry，那最后的输出文件是/home/harry/log/output.log。
\emph on
转换格式串
\emph default
详见 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Conversion-pattern"

\end_inset

。
\end_layout

\begin_layout Standard

\emph on
文件限制
\emph default
 控制文件的大小和个数。zlog根据这个字段来转档，当日志文件太大的时候。例如
\end_layout

\begin_layout LyX-Code
\begin_inset Quotes eld
\end_inset

%E(HOME)/log/out.log
\begin_inset Quotes erd
\end_inset

,1M*3
\end_layout

\begin_layout Standard
如果out.log被写到1M大，转档动作为：
\end_layout

\begin_layout LyX-Code
out.log -> out.log.1
\end_layout

\begin_layout LyX-Code
out.log(new create) 
\end_layout

\begin_layout Standard
如果新的日志文件再次被写满，转档动作为：
\end_layout

\begin_layout LyX-Code
out.log.1 -> out.log.2
\end_layout

\begin_layout LyX-Code
out.log -> out.log.1
\end_layout

\begin_layout LyX-Code
out.log(new create)
\end_layout

\begin_layout Standard
下一次的转档会把最旧的日志文件删除掉， *3意味着zlog会保留3个文件：
\end_layout

\begin_layout LyX-Code
unlink(out.log.2)
\end_layout

\begin_layout LyX-Code
out.log.1 -> out.log.2
\end_layout

\begin_layout LyX-Code
out.log -> out.log.1
\end_layout

\begin_layout LyX-Code
out.log(new create)
\end_layout

\begin_layout Standard
最旧的文件有最大的序列号
\end_layout

\begin_layout Standard

\emph on
格式名
\emph default
 是可选的，如果不写，用全局配置里面的默认格式：
\end_layout

\begin_layout LyX-Code
&default "%d(%F %T) %P [%p:%F:%L] %m%n"
\end_layout

\begin_layout Standard
这种格式会输出类似这样的日志：
\end_layout

\begin_layout LyX-Code
2012-02-14 17:03:12 INFO [3758:test_hello.c:39] hello, zlog
\end_layout

\begin_layout Standard
规则可以用自己的格式，一个格式可以被多条规则使用。如果在某条规则前写这样的格式：
\end_layout

\begin_layout LyX-Code
&simple "%m%n
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
my_cat.*    >stdout; simple
\end_layout

\begin_layout Standard
最后的输出是：
\end_layout

\begin_layout LyX-Code
hello, zlog
\end_layout

\begin_layout Standard
格式(format)的语法是：
\end_layout

\begin_layout Standard
&[格式名][n个空格或tab]"[转换格式串]"
\end_layout

\begin_layout Section
转换格式串
\begin_inset CommandInset label
LatexCommand label
name "sec:Conversion-pattern"

\end_inset


\end_layout

\begin_layout Standard
转换格式串的设计是从C的printf函数里面抄来的。一个转换格式串由文本字符和转换说明组成。
\end_layout

\begin_layout Standard
转换格式串用在规则的日志文件路径和输出格式(format)中。
\end_layout

\begin_layout Standard
你可以把任意的文本字符放到转换格式串里面。
\end_layout

\begin_layout Standard
每个转换说明都是以百分号(%)打头的，后面跟可选的宽度修饰符，最后以转换字符结尾。转换字符决定了输出什么数据，例如分类名、级别、时间日期、进程号等等。宽度修饰符
控制了这个字段的最大最小宽度、左右对齐。下面是简单的例子。
\end_layout

\begin_layout Standard
如果转换格式串是：
\end_layout

\begin_layout LyX-Code
"%d(%m-%d %T) %-5P [%p:%F:%L] %m%n".
\end_layout

\begin_layout Standard
源代码中的写日志语句是：
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(c, "hello, zlog");
\end_layout

\begin_layout Standard
将会输出：
\end_layout

\begin_layout LyX-Code
02-14 17:17:42 INFO  [4935:test_hello.c:39] hello, zlog
\end_layout

\begin_layout Standard
可以注意到，在文本字符和转换说明之间没有显式的分隔符。zlog解析的时候知道哪里是转换说明的开头和结尾。在这个例子里面%-5p这个转换说明决定了日志级别要被左对
齐，占5个字符宽。 
\end_layout

\begin_layout Subsection
转换字符
\end_layout

\begin_layout Standard
可以被辨认的转换字符是
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="17" columns="3">
<features islongtable="true">
<column alignment="center" valignment="top" width="10text%">
<column alignment="center" valignment="top" width="50text%">
<column alignment="center" valignment="top" width="40text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
字符
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
效果
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
例子
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
分类名 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aa_bb
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%d
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
打日志的时间。这个后面要跟一对小括号()内含说明具体的日期格式。就像%d(%F)或者%d(%m-%d %T)。如果不跟小括号，默认是%d(%F
 %T)。括号内的格式和 strftime(3)的格式一致，就是增加了%us表示微秒，还有
\end_layout

\begin_layout Plain Layout
%ms表示毫秒。详见
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Time-Character"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%d(%F) 2011-12-01
\end_layout

\begin_layout Plain Layout
%d(%m-%d %T) 12-01 17:17:42
\end_layout

\begin_layout Plain Layout
%d(%T.ms) 17:17:42.035
\end_layout

\begin_layout Plain Layout
%d 2012-02-14 17:03:12
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
环境变量，后面也要跟小括号，内涵环境变量的键。变量的值在zlog_init()的时候就求出来了
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%E(HOME) /home/harry
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
源代码文件名，来源于__FILE__宏。在某些编译器下 __FILE__是绝对路径。用$f来去掉目录只保留文件名，或者编译器有选项可以调节
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
test_hello.c
\end_layout

\begin_layout Plain Layout
或者在某些编译器下
\end_layout

\begin_layout Plain Layout
/home/zlog/src/test/test_hello.c
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
源代码文件名，输出$F最后一个'/'后面的部分。当然这会有一定的性能损失
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
test_hello.c
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%H
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
主机名，来源于 gethostname(2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
zlog-dev
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%L
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
源代码行数，来源于__LINE__宏
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
135
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
用户日志，用户从zlog函数输入的日志。
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
hello, zlog
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%M
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MDC (mapped diagnostic context)，每个线程一张键值对表，输出键相对应的值。后面必需跟跟一对小括号()内含键。例如
 %M(clientNumber) ，clientNumbe是键。 详见 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:MDC"

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%M(clientNumber) 12345
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
换行符，目前还不支持windows换行符
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
n
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%p
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
进程ID，来源于getpid()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2134
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%V
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
日志级别，大写
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INFO
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
日志级别，小写
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
info
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
线程ID，来源于pthread_self().
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7636
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
一个百分号
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%[其他字符]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
解析为错误，zlog_init()将会失败
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
宽度修饰符 
\end_layout

\begin_layout Standard
一般来说数据按原样输出。不过，有了宽度修饰符，就能够控制最小字段宽度、最大字段宽度和左右对齐。当然这要付出一定的性能代价。
\end_layout

\begin_layout Standard
可选的宽度修饰符放在百分号和转换字符之间。
\end_layout

\begin_layout Standard
第一个可选的宽度修饰符是左对齐标识，减号(-)。然后是可选的最小字段宽度，这是一个十进制数字常量，表示最少有几个字符会被输出。如果数据本来没有那么多字符，将会填
充空格（左对齐或者右对齐）直到最小字段宽度为止。默认是填充在左边也就是右对齐。当然你也可以使用左对齐标志，指定为填充在右边来左对齐。填充字符为空格(space)
。如果数据的宽度超过最小字段宽度，则按照数据的宽度输出，永远不会截断数据。
\end_layout

\begin_layout Standard
这种行为可以用最大字段宽度来改变。最大字段宽度是放在一个句点号(.)后面的十进制数字常量。如果数据的宽度超过了最大字段宽度，则尾部多余的字符（超过最大字段宽度的部
分）将会被截去。 最大字段宽度是8，数据的宽度是10，则最后两个字符会被丢弃。假如这种行为和C的printf是一样的，把后面的部分截断。
\end_layout

\begin_layout Standard
下面是各种宽度修饰符和分类转换字符配合一起用的例子。
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="5">
<features>
<column alignment="center" valignment="top" width="15text%">
<column alignment="center" valignment="top" width="10text%">
<column alignment="center" valignment="top" width="10text%">
<column alignment="center" valignment="top" width="10text%">
<column alignment="center" valignment="top" width="60text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
宽度修饰符
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
左对齐
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
最小字段宽度
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
最大字段宽度
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
附注
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%20c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
否
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
无
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
左补充空格，如果分类名小于20个字符长。
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%-20c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
是
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
无
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
右补充空格，如果分类名小于20个字符长。
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%.30c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
无
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
无
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
如果分类名大于30个字符长，取前30个字符，去掉后面的。
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%20.30c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
否
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
如果分类名小于20个字符长，左补充空格。如果在20-30之间，按照原样输出。如果大于30个字符长，取前30个字符，去掉后面的。
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%-20.30c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
是
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
如果分类名小于20个字符长，右补充空格。如果在20-30之间，按照原样输出。如果大于30个字符长，取前30个字符，去掉后面的。
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
时间字符
\begin_inset CommandInset label
LatexCommand label
name "sub:Time-Character"

\end_inset


\end_layout

\begin_layout Standard
这里是转换字符d支持的时间字符。
\end_layout

\begin_layout Standard
其中2个是zlog特有的，取自gettimeofday(2)
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features>
<column alignment="center" valignment="top" width="10text%">
<column alignment="center" valignment="top" width="60text%">
<column alignment="center" valignment="top" width="30text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
词
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
效果
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
例子
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%ms
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
毫秒，3位数字字符串
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
013
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%us
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
微秒，6位数字字符串
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
002323
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
其他的字符都是由strftime(2)生成的，在我的linux操作系统上支持的是：
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="42" columns="3">
<features islongtable="true">
<column alignment="center" valignment="top" width="10text%">
<column alignment="center" valignment="top" width="60text%">
<column alignment="center" valignment="top" width="30text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
字符
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
效果
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
例子
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
一星期中各天的缩写名，根据locale显示
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Wed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
一星期中各天的全名，根据locale显示
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Wednesday
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
缩写的月份名，根据locale显示
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mar
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
月份全名，根据locale显示
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
March
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
当地时间和日期的全表示， 根据locale显示
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Thu Feb 16 14:16:35 2012
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
世纪 (年/100)，2位的数字(SU)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%d
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
一个月中的某一天 (01-31)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
06
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
相当于%m/%d/%y.
 (呃，美国人专用，美国人要知道在别的国家%d/%m/%y 才是主流。也就是说在国际环境下这个格式容易造成误解，要少用) (SU)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
02/16/12
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%e
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
就像%d，一个月中的某一天，但是头上的0被替换成空格(SU)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
相当于%Y-%m-%d (ISO 8601日期格式)(C99) 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2012-02-16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The ISO 8601 week-based year (see NOTES) with century as a decimal number.
 The 4-digit year corre‐ sponding to the ISO week number (see %V).
 This has the same format and value as %Y, except that if the ISO week number
 belongs to the previous or next year, that year is used instead.
 (TZ)
\end_layout

\begin_layout Plain Layout
大意是采用%V定义的年，如果那年的前几天不算新年的第一周，就算上一年
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2012
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%g
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
相当于%G，就是不带世纪 (00-99).
 (TZ)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
相当于%b(SU)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Feb
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%H
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
小时，24小时表示(00-23)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
小时，12小时表示(01-12)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
02
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%j
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
一年中的各天(001-366)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
047
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%k
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
小时，24小时表示( 0-23)； 一位的前面为空格 (可和%H比较) (TZ)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%l
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
小时，12小时表示( 0-12)； 一位的前面为空格 (可和%比较)(TZ)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
月份(01-12)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
02
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%M
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
分钟(00-59)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
换行符 (SU) 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
n
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%p
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
"AM" 或 "PM"，根据当时的时间，根据locale显示相应的值，例如
\begin_inset Quotes erd
\end_inset

上午“、”下午“ 。 中午是"PM"，凌晨是"AM"
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PM
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
相当于%p不过是小写，根据locale显示相应的值 (GNU)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pm
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
时间+后缀AM或PM。在POSIX locale下相当于%I:%M:%S %p.
 (SU)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
03:11:54 PM
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
小时(24小时制):分钟 (%H:%M) (SU) 如果要带秒的，见%T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15:11
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Epoch以来的秒数，也就是从1970-01-01 00:00:00 UTC.
 (TZ)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1329376487
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
秒(00-60).
 (允许60是为了闰秒)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
54
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
制表符tab(SU)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
小时(24小时制):分钟:秒 (%H:%M:%S) (SU)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15:14:47
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
一周的天序号(1-7)，周一是1，另见%w (SU)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
一年中的星期序号(00-53)，周日是一周的开始，一年中第一个周日所在的周是第01周。另见%V和%W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
07
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%V
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ISO 8601星期序号(01-53)，01周是第一个至少有4天在新年的周。另见%U 和%W(SU)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
07
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
一周的天序号(0-6)，周日是0。另见%u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
一年中的星期序号(00-53)，周一是一周的开始，一年中第一个周一所在的周是第01周。另见%V和%W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
07
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
当前locale下的偏好日期
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
02/16/12
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
当前locale下的偏好时间
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15:14:47
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
不带世纪数目的年份(00-99)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%Y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
带世纪数目的年份
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2012
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%z
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
当前时区相对于GMT时间的偏移量。采用RFC 822-conformant来计算(话说我也不知道是啥) (using "%a, %d %b %Y
 %H:%M:%S %z").
 (GNU)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+0800
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%Z
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
时区名(如果有的话)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CST
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
一个百分号
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
配置文件工具
\end_layout

\begin_layout LyX-Code
$ zlog-chk-conf -h 
\end_layout

\begin_layout LyX-Code
Useage: zlog-chk-conf [conf files]...
 	
\end_layout

\begin_layout LyX-Code
-q,	suppress non-error message 	
\end_layout

\begin_layout LyX-Code
-h,	show help message
\end_layout

\begin_layout Standard
zlog-chk-conf 尝试读取配置文件，检查语法，然后往屏幕上输出这些配置文件是否正确。我建议每次创建或者改动一个配置文件之后都用一下这个工具。输出可能是
这样：
\end_layout

\begin_layout LyX-Code
$ ./zlog-chk-conf zlog.conf
\end_layout

\begin_layout LyX-Code
03-08 15:35:44 ERROR (10595:rule.c:391) sscanf [aaa] fail, category or level
 is null 
\end_layout

\begin_layout LyX-Code
03-08 15:35:44 ERROR (10595:conf.c:155) zlog_rule_new fail [aaa] 
\end_layout

\begin_layout LyX-Code
03-08 15:35:44 ERROR (10595:conf.c:258) parse configure file[zlog.conf] line[126]
 fail 
\end_layout

\begin_layout LyX-Code
03-08 15:35:44 ERROR (10595:conf.c:306) zlog_conf_read_config fail 
\end_layout

\begin_layout LyX-Code
03-08 15:35:44 ERROR (10595:conf.c:366) zlog_conf_build fail 
\end_layout

\begin_layout LyX-Code
03-08 15:35:44 ERROR (10595:zlog.c:66) conf_file[zlog.conf], init conf fail
 
\end_layout

\begin_layout LyX-Code
03-08 15:35:44 ERROR (10595:zlog.c:131) zlog_init_inner[zlog.conf] fail
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
---[zlog.conf] syntax error, see error message above
\end_layout

\begin_layout Standard
这个告诉你配置文件zlog.conf的126行，是错的。第一行进一步告诉你[aaa]不是一条正确的规则。
\end_layout

\begin_layout Standard
zlog-chk-conf可以同时分析多个配置文件，举例：
\end_layout

\begin_layout LyX-Code
$ zlog-chk-conf zlog.conf ylog.conf 
\end_layout

\begin_layout LyX-Code
--[zlog.conf] syntax right 
\end_layout

\begin_layout LyX-Code
--[ylog.conf] syntax right 
\end_layout

\begin_layout Standard
还有一个有用的工具是
\end_layout

\begin_layout LyX-Code
$ zlog-gen-conf -h 
\end_layout

\begin_layout LyX-Code
Useage: zlog-gen-conf [conf file] 
\end_layout

\begin_layout LyX-Code
If no filename is specified, use zlog.conf as default
\end_layout

\begin_layout LyX-Code
-c 	Chinese comment(UTF-8)
\end_layout

\begin_layout LyX-Code
         if envrionment is GBK, use
\end_layout

\begin_layout LyX-Code
         $ iconv -f UTF-8 -t GBK xx.conf > yy.conf
\end_layout

\begin_layout LyX-Code
         $ mv yy.conf xx.conf
\end_layout

\begin_layout LyX-Code
-e 	Enligsh comment
\end_layout

\begin_layout LyX-Code
-h,	show help message 
\end_layout

\begin_layout Standard
这个工具会产生一个模板配置文件，可以带中文或者英文的注释，注释是这一章内容的浓缩总结。
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Chapter
zlog应用编程接口(API)
\end_layout

\begin_layout Standard
zlog的所有函数都是线程安全的，使用的时候只需要
\end_layout

\begin_layout LyX-Code
#include 
\begin_inset Quotes eld
\end_inset

zlog.h
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Section
初始化和清理
\end_layout

\begin_layout LyX-Code
int zlog_init(char *conf_file);
\end_layout

\begin_layout LyX-Code
int zlog_reload(char *conf_file);
\end_layout

\begin_layout LyX-Code
void zlog_fini(void);
\end_layout

\begin_layout Standard
zlog_init() 从配置文件中读取配置信息到内存。如果conf_file为NULL，所有日志以内置格式写到标准输出上。如果zlog_init()失败，详细
错误会被记录在ZLOG_PROFILE_ERROR(see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Profile-zlog-Itself"

\end_inset

)，并且返回-1。每个进程只有第一次调用zlog_init()是有效的，后面的多余调用都会失败。 
\end_layout

\begin_layout Standard
zlog_reload()是用来重载配置，并根据这个配置文件来重计算内部的分类规则匹配、重建每个线程的缓存。可以在配置文件发生改变后调用这个函数。这个函数使用次
数不限。如果conf_file 为NULL，会重载上一次zlog_init()或者zlog_reload()使用的配置文件。如果失败，返回-1，同时zlog后续
无法使用。
\end_layout

\begin_layout Standard
zlog_fini()清理所有zlog API申请的内存，关闭它们打开的文件。
\end_layout

\begin_layout Section
分类(Category)操作
\end_layout

\begin_layout LyX-Code
typedef struct zlog_category_t zlog_category_t;
\end_layout

\begin_layout LyX-Code
zlog_category_t *zlog_get_category(char *category_name);
\end_layout

\begin_layout Standard
zlog_get_category()从全局的分类表里面取得一个分类，如果没有的话，创建一个。成功返回分类的指针，失败则返回NULL。category_name
 需要和配置文件的规则想对应，详见
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Select-Input"

\end_inset

。不用担心内存释放，zlog_fini()最后会进行清理。
\end_layout

\begin_layout Section
写日志函数
\end_layout

\begin_layout LyX-Code
void zlog(zlog_category_t * a_cat, 
\end_layout

\begin_layout LyX-Code
             char *file, long line, 
\end_layout

\begin_layout LyX-Code
             int level,
\end_layout

\begin_layout LyX-Code
             char *format, ...);
\end_layout

\begin_layout LyX-Code
void vzlog(zlog_category_t * a_cat,
\end_layout

\begin_layout LyX-Code
             char *file, long line,
\end_layout

\begin_layout LyX-Code
             int level,
\end_layout

\begin_layout LyX-Code
             char *format, va_list args); 
\end_layout

\begin_layout LyX-Code
void hzlog(zlog_category_t * a_cat,
\end_layout

\begin_layout LyX-Code
             char *file, long line,
\end_layout

\begin_layout LyX-Code
             int level,
\end_layout

\begin_layout LyX-Code
             void *buf, size_t buf_len); 
\end_layout

\begin_layout Standard
这3个函数是用户写日志的函数，输入的数据对应于配置文件中的%m。a_cat来自于调用zlog_get_category()。
\end_layout

\begin_layout Standard
zlog()和vzlog()根据format输出，就像printf(3)和vprintf(3)。
\end_layout

\begin_layout Standard
vzlog()相当于zlog()，只是它用一个va_list类型的参数args，而不是一堆类型不同的参数。vzlog() 内部使用了 va_copy
 宏，args的内容在vzlog()后保持不变，可以参考stdarg(3)。
\end_layout

\begin_layout Standard
hzlog()有点不一样，它产生下面这样的输出，长度为buf_len的内存buf以16进制的形式表示出来
\emph on
。
\end_layout

\begin_layout LyX-Code
hex_buf_len=[5365]  
\end_layout

\begin_layout LyX-Code
             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F      0123456789ABCDE
F
\end_layout

\begin_layout LyX-Code
0000000001   23 21 20 2f 62 69 6e 2f 62 61 73 68 0a 0a 23 20   #! /bin/bash..#
\end_layout

\begin_layout LyX-Code
0000000002   74 65 73 74 5f 68 65 78 20 2d 20 74 65 6d 70 6f   test_hex
 - tempo
\end_layout

\begin_layout LyX-Code
0000000003   72 61 72 79 20 77 72 61 70 70 65 72 20 73 63 72   rary wrapper
 scr
\end_layout

\begin_layout Standard
参数file、line一般填写为__FILE__，__LINE__宏。这两个参数表明了日志是在哪里记录的。
\end_layout

\begin_layout Standard
level 是一个int型变量，默认在zlog.h里面定义为
\end_layout

\begin_layout LyX-Code
typedef enum {                 
\end_layout

\begin_deeper
\begin_layout LyX-Code
ZLOG_LEVEL_DEBUG = 20,
\end_layout

\begin_layout LyX-Code
ZLOG_LEVEL_INFO = 40,
\end_layout

\begin_layout LyX-Code
ZLOG_LEVEL_NOTICE = 60,
\end_layout

\begin_layout LyX-Code
ZLOG_LEVEL_WARN = 80,
\end_layout

\begin_layout LyX-Code
ZLOG_LEVEL_ERROR = 100,
\end_layout

\begin_layout LyX-Code
ZLOG_LEVEL_FATAL = 120
\end_layout

\end_deeper
\begin_layout LyX-Code
} zlog_level;
\end_layout

\begin_layout Section
写日志宏
\end_layout

\begin_layout Standard
为了简单使用，在zlog.h内定义了如下宏
\end_layout

\begin_layout Standard
zlog()的宏
\end_layout

\begin_layout LyX-Code
#define ZLOG_FATAL(cat, format, args...) 
\backslash

\end_layout

\begin_layout LyX-Code
zlog(cat, __FILE__, __LINE__, ZLOG_LEVEL_FATAL, format, ##args)
\end_layout

\begin_layout LyX-Code
#define ZLOG_ERROR(cat, format, args...) 
\backslash

\end_layout

\begin_layout LyX-Code
zlog(cat, __FILE__, __LINE__, ZLOG_LEVEL_ERROR, format, ##args)
\end_layout

\begin_layout LyX-Code
#define ZLOG_WARN(cat, format, args...) 
\backslash

\end_layout

\begin_layout LyX-Code
zlog(cat, __FILE__, __LINE__, ZLOG_LEVEL_WARN, format, ##args)
\end_layout

\begin_layout LyX-Code
#define ZLOG_NOTICE(cat, format, args...) 
\backslash

\end_layout

\begin_layout LyX-Code
zlog(cat, __FILE__, __LINE__, ZLOG_LEVEL_NOTICE, format, ##args)
\end_layout

\begin_layout LyX-Code
#define ZLOG_INFO(cat, format, args...) 
\backslash

\end_layout

\begin_layout LyX-Code
zlog(cat, __FILE__, __LINE__, ZLOG_LEVEL_INFO, format, ##args)
\end_layout

\begin_layout LyX-Code
#define ZLOG_DEBUG(cat, format, args...) 
\backslash

\end_layout

\begin_layout LyX-Code
zlog(cat, __FILE__, __LINE__, ZLOG_LEVEL_DEBUG, format, ##args) 
\end_layout

\begin_layout Standard
vzlog()的宏
\end_layout

\begin_layout LyX-Code
#define VZLOG_FATAL(cat, format, args) 
\backslash

\end_layout

\begin_layout LyX-Code
vzlog(cat, __FILE__, __LINE__, ZLOG_LEVEL_FATAL, format, args)
\end_layout

\begin_layout LyX-Code
#define VZLOG_ERROR(cat, format, args) 
\backslash

\end_layout

\begin_layout LyX-Code
vzlog(cat, __FILE__, __LINE__, ZLOG_LEVEL_ERROR, format, args)
\end_layout

\begin_layout LyX-Code
#define VZLOG_WARN(cat, format, args) 
\backslash

\end_layout

\begin_layout LyX-Code
vzlog(cat, __FILE__, __LINE__, ZLOG_LEVEL_WARN, format, args)
\end_layout

\begin_layout LyX-Code
#define VZLOG_NOTICE(cat, format, args) 
\backslash

\end_layout

\begin_layout LyX-Code
vzlog(cat, __FILE__, __LINE__, ZLOG_LEVEL_NOTICE, format, args)
\end_layout

\begin_layout LyX-Code
#define VZLOG_INFO(cat, format, args) 
\backslash

\end_layout

\begin_layout LyX-Code
vzlog(cat, __FILE__, __LINE__, ZLOG_LEVEL_INFO, format, args)
\end_layout

\begin_layout LyX-Code
#define VZLOG_DEBUG(cat, format, args) 
\backslash

\end_layout

\begin_layout LyX-Code
vzlog(cat, __FILE__, __LINE__, ZLOG_LEVEL_DEBUG, format, args) 
\end_layout

\begin_layout Standard
hzlog()的宏
\end_layout

\begin_layout LyX-Code
#define HZLOG_FATAL(cat, buf, buf_len) 
\backslash

\end_layout

\begin_layout LyX-Code
hzlog(cat, __FILE__, __LINE__, ZLOG_LEVEL_FATAL, buf, buf_len)
\end_layout

\begin_layout LyX-Code
#define HZLOG_ERROR(cat, buf, buf_len) 
\backslash

\end_layout

\begin_layout LyX-Code
hzlog(cat, __FILE__, __LINE__, ZLOG_LEVEL_ERROR, buf, buf_len)
\end_layout

\begin_layout LyX-Code
#define HZLOG_WARN(cat, buf, buf_len) 
\backslash

\end_layout

\begin_layout LyX-Code
hzlog(cat, __FILE__, __LINE__, ZLOG_LEVEL_WARN, buf, buf_len)
\end_layout

\begin_layout LyX-Code
#define HZLOG_NOTICE(cat, buf, buf_len) 
\backslash

\end_layout

\begin_layout LyX-Code
hzlog(cat, __FILE__, __LINE__, ZLOG_LEVEL_NOTICE, buf, buf_len)
\end_layout

\begin_layout LyX-Code
#define HZLOG_INFO(cat, buf, buf_len) 
\backslash

\end_layout

\begin_layout LyX-Code
hzlog(cat, __FILE__, __LINE__, ZLOG_LEVEL_INFO, buf, buf_len)
\end_layout

\begin_layout LyX-Code
#define HZLOG_DEBUG(cat, buf, buf_len) 
\backslash

\end_layout

\begin_layout LyX-Code
hzlog(cat, __FILE__, __LINE__, ZLOG_LEVEL_DEBUG, buf, buf_len) 
\end_layout

\begin_layout Section
MDC操作
\end_layout

\begin_layout Standard
MDC(Mapped Diagnostic Context)是一个每线程拥有的键-值表，所以和分类没啥关系。操作函数为
\end_layout

\begin_layout LyX-Code
int zlog_put_mdc(char *key, char *value);
\end_layout

\begin_layout LyX-Code
char *zlog_get_mdc(char *key);
\end_layout

\begin_layout LyX-Code
void zlog_remove_mdc(char *key);
\end_layout

\begin_layout LyX-Code
void zlog_clean_mdc(void);
\end_layout

\begin_layout Standard
键和值都是字符串，长度不能超过MAXLEN_PATH(一般来说是1024)。记住这个表是和线程绑定的，每个线程有自己的表，所以在一个线程内的操作不会影响其他线程
。
\end_layout

\begin_layout Standard
zlog_put_mdc()成功返回0，失败返回-1。zlog_get_mdc()成功返回value的指针，失败或者没有相应的key返回NULL。
\end_layout

\begin_layout Section
dzlog应用编程接口(API)
\begin_inset CommandInset label
LatexCommand label
name "sec:dzlog-API"

\end_inset


\end_layout

\begin_layout Standard
dzlog是忽略分类(zlog_category_t)的一组zlog接口。它采用内置的一个默认分类，这个分类置于锁的保护下。这些接口也是线程安全的。忽略了分类，
意味着用户不需要操心创建、存储、传输zlog_category_t类型的变量
\emph on
\noun on
。当然也可以在用
\emph default
\noun default
dzlog接口的同时用一般的zlog接口函数。
\end_layout

\begin_layout LyX-Code
int dzlog_init(char *conf_file, char *default_category_name);
\end_layout

\begin_layout LyX-Code
int dzlog_set_category(char *default_category_name);
\end_layout

\begin_layout Standard
dzlog_init()和zlog_init()一样做初始化，就是多需要一个默认分类名(default_category_name)的参数。zlog_reloa
d()、 zlog_fini() 可以和以前一样使用，用来刷新配置，或者清理。
\end_layout

\begin_layout Standard
dzlog_set_category()是用来改变默认分类用的。上一个分类会被替换成新的。同样不用担心内存释放的问题，zlog_fini()最后会清理。
\end_layout

\begin_layout LyX-Code
void dzlog(char *file, long line, int level, char *format, ...);
\end_layout

\begin_layout LyX-Code
void vdzlog(char *file, long line, int level, char *format, va_list args);
\end_layout

\begin_layout LyX-Code
void hdzlog(char *file, long line, int level, void *buf, size_t buf_len);
\end_layout

\begin_layout Standard
这是dzlog相应的3个写日志的函数。
\end_layout

\begin_layout LyX-Code
DZLOG_FATAL(format, args...)
\end_layout

\begin_layout LyX-Code
DZLOG_ERROR(format, args...)
\end_layout

\begin_layout LyX-Code
DZLOG_WARN(format, args...)
\end_layout

\begin_layout LyX-Code
DZLOG_NOTICE(format, args...)
\end_layout

\begin_layout LyX-Code
DZLOG_INFO(format, args...)
\end_layout

\begin_layout LyX-Code
DZLOG_DEBUG(format, args...)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
VDZLOG_FATAL(format, args)
\end_layout

\begin_layout LyX-Code
VDZLOG_ERROR(format, args)
\end_layout

\begin_layout LyX-Code
VDZLOG_WARN(format, args)
\end_layout

\begin_layout LyX-Code
VDZLOG_NOTICE(format, args)
\end_layout

\begin_layout LyX-Code
VDZLOG_INFO(format, args)
\end_layout

\begin_layout LyX-Code
VDZLOG_DEBUG(format, args)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
HDZLOG_FATAL(buf, buf_len)
\end_layout

\begin_layout LyX-Code
HDZLOG_ERROR(buf, buf_len)
\end_layout

\begin_layout LyX-Code
HDZLOG_WARN(buf, buf_len)
\end_layout

\begin_layout LyX-Code
HDZLOG_NOTICE(buf, buf_len)
\end_layout

\begin_layout LyX-Code
HDZLOG_INFO(buf, buf_len)
\end_layout

\begin_layout LyX-Code
HDZLOG_DEBUG(buf, buf_len)
\end_layout

\begin_layout Standard
同样也有相应的宏，一般都用这组来写。
\end_layout

\begin_layout Chapter
高阶使用
\end_layout

\begin_layout Section
MDC
\begin_inset CommandInset label
LatexCommand label
name "sec:MDC"

\end_inset


\end_layout

\begin_layout Standard
MDC是什么？在log4j里面解释为Mapped Diagnostic Context。听起来是个很复杂的技术，其实MDC就是一个键-值对表。一旦某次你设置了，
后面库可以帮你自动打印出来，或者成为文件名的一部分。让我们看一个例子，来自于$(top_builddir)/test/test_mdc.c.
\end_layout

\begin_layout LyX-Code
$ cat test_mdc.c
\end_layout

\begin_layout LyX-Code
#include <stdio.h>
\end_layout

\begin_layout LyX-Code
#include <stdlib.h>
\end_layout

\begin_layout LyX-Code
#include <sys/types.h>
\end_layout

\begin_layout LyX-Code
#include <unistd.h>
\end_layout

\begin_layout LyX-Code
#include <string.h>
\end_layout

\begin_layout LyX-Code
#include "zlog.h"
\end_layout

\begin_layout LyX-Code
int main(int argc, char** argv)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_deeper
\begin_layout LyX-Code
int rc;
\end_layout

\begin_layout LyX-Code
zlog_category_t *zc;
\end_layout

\begin_layout LyX-Code
rc = zlog_init("test_mdc.conf");
\end_layout

\begin_deeper
\begin_layout LyX-Code
if (rc) { 
\end_layout

\begin_layout LyX-Code
printf("init failed
\backslash
n");
\end_layout

\begin_layout LyX-Code
return -1;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
zc = zlog_get_category("my_cat");
\end_layout

\begin_layout LyX-Code
if (!zc) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
printf("get cat fail
\backslash
n");
\end_layout

\begin_layout LyX-Code
zlog_fini();
\end_layout

\begin_layout LyX-Code
return -2;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(zc, "1.hello, zlog");
\end_layout

\begin_layout LyX-Code
zlog_put_mdc("myname", "Zhang");
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(zc, "2.hello, zlog");
\end_layout

\begin_layout LyX-Code
zlog_put_mdc("myname", "Li");
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(zc, "3.hello, zlog"); 
\end_layout

\begin_layout LyX-Code
zlog_fini(); 
\end_layout

\begin_layout LyX-Code
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code
} 
\end_layout

\begin_layout Standard
配置文件
\end_layout

\begin_layout LyX-Code
$ cat test_mdc.conf
\end_layout

\begin_layout LyX-Code
&mdc_format    "%d(%F %X.%ms) %-6V (%c:%F:%L) [%M(myname)] - %m%n"
\end_layout

\begin_layout LyX-Code
*.*             >stdout; mdc_format
\end_layout

\begin_layout Standard
输出
\end_layout

\begin_layout LyX-Code
$ ./test_mdc
\end_layout

\begin_layout LyX-Code
2012-03-12 09:26:37.740 INFO   (my_cat:test_mdc.c:47) [] - 1.hello, zlog 
\end_layout

\begin_layout LyX-Code
2012-03-12 09:26:37.740 INFO   (my_cat:test_mdc.c:51) [Zhang] - 2.hello, zlog
 
\end_layout

\begin_layout LyX-Code
2012-03-12 09:26:37.740 INFO   (my_cat:test_mdc.c:55) [Li] - 3.hello, zlog
\end_layout

\begin_layout Standard
你可以看到zlog_put_mdc()在表里面设置键
\begin_inset Quotes eld
\end_inset

myname
\begin_inset Quotes erd
\end_inset

对应值
\begin_inset Quotes eld
\end_inset

Zhang
\begin_inset Quotes erd
\end_inset

，然后在配置文件里面%M(myname)指出了在日志的哪个位置需要把值打出来。第二次，键
\begin_inset Quotes eld
\end_inset

myname
\begin_inset Quotes erd
\end_inset

的值被覆盖写成
\begin_inset Quotes eld
\end_inset

Li
\begin_inset Quotes erd
\end_inset

，然后日志里面也有相应的变化。
\end_layout

\begin_layout Standard
MDC什么时候有用呢？往往在用户需要在同样的日志行为区分不同的业务数据的时候。比如说，c源代码是
\end_layout

\begin_layout LyX-Code
zlog_put_mdc(
\begin_inset Quotes eld
\end_inset

customer_name
\begin_inset Quotes erd
\end_inset

, get_customer_name_from_db() );
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(
\begin_inset Quotes eld
\end_inset

get in
\begin_inset Quotes erd
\end_inset

); 
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(
\begin_inset Quotes eld
\end_inset

pick product
\begin_inset Quotes erd
\end_inset

); 
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(
\begin_inset Quotes eld
\end_inset

pay
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(
\begin_inset Quotes eld
\end_inset

get out
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Standard
在配置文件里面是
\end_layout

\begin_layout LyX-Code
&format  
\begin_inset Quotes eld
\end_inset

%M(customer_name) %m%n
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
当程序同时处理两个用户的时候，打出来的日志可能是
\end_layout

\begin_layout LyX-Code
Zhang get in
\end_layout

\begin_layout LyX-Code
Li get in
\end_layout

\begin_layout LyX-Code
Zhang pick product
\end_layout

\begin_layout LyX-Code
Zhang pay
\end_layout

\begin_layout LyX-Code
Li pick product
\end_layout

\begin_layout LyX-Code
Li pay
\end_layout

\begin_layout LyX-Code
Zhang get out
\end_layout

\begin_layout LyX-Code
Li get out
\end_layout

\begin_layout Standard
这样，你就可以用grep命令把这两个用户的日志分开来了
\end_layout

\begin_layout LyX-Code
$ grep Zhang aa.log > Zhang.log
\end_layout

\begin_layout LyX-Code
$ grep Li aa.log >Li.log
\end_layout

\begin_layout Standard
或者，还有另外一条路，一开始在文件名里面做区分，看配置文件：
\end_layout

\begin_layout LyX-Code
*.* "mdc_%M(customer_name).log";
\end_layout

\begin_layout Standard
这就会产生3个日志文件。
\end_layout

\begin_layout LyX-Code
mdc_.log mdc_Zhang.log mdc_Li.log
\end_layout

\begin_layout Standard
这是一条近路，如果用户知道自己在干什么。
\end_layout

\begin_layout Standard
MDC是每个线程独有的，所以可以把一些线程专有的变量设置进去。如果单单为了区分线程，可以用转换字符里面的%t来搞定。
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Section
诊断zlog本身
\begin_inset CommandInset label
LatexCommand label
name "sec:Profile-zlog-Itself"

\end_inset


\end_layout

\begin_layout Standard
OK，至今为止，我假定zlog库本身是不出毛病的。zlog帮助用户程序写日志，帮助程序员debug程序。但是如果zlog内部出错了呢？怎么知道错在哪里呢？其他的
程序可以用日志库来debug，但日志库自己怎么debug？答案很简单，zlog有自己的日志——诊断日志。这个日志通常是关闭的，可以通过环境变量来打开。
\end_layout

\begin_layout LyX-Code
$ export ZLOG_PROFILE_DEBUG=/tmp/zlog.debug.log
\end_layout

\begin_layout LyX-Code
$ export ZLOG_PROFILE_ERROR=/tmp/zlog.error.log
\end_layout

\begin_layout Standard
诊断日志只有两个级别debug和error。设置好环境变量后.
 再跑test_hello程序
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Hello-World-Example"

\end_inset

，然后debug日志为
\end_layout

\begin_layout LyX-Code
$ more zlog.debug.log 
\end_layout

\begin_layout LyX-Code
03-13 09:46:56 DEBUG (7503:zlog.c:115) ------zlog_init start, compile time[Mar
 13 2012 11:28:56]------ 
\end_layout

\begin_layout LyX-Code
03-13 09:46:56 DEBUG (7503:spec.c:825) spec:[0x7fdf96b7c010][%d(%F %T)][%F
 %T 29][] 
\end_layout

\begin_layout LyX-Code
03-13 09:46:56 DEBUG (7503:spec.c:825) spec:[0x7fdf96b52010][ ][ 0][] 
\end_layout

\begin_layout LyX-Code
......
\end_layout

\begin_layout LyX-Code
03-13 09:52:40 DEBUG (8139:zlog.c:291) ------zlog_fini end------
\end_layout

\begin_layout Standard
zlog.error.log日志没产生，因为没有错误发生。
\end_layout

\begin_layout Standard
你可以看出来，debug日志展示了zlog是怎么初始化还有清理的。不过在ZLOG_INFO()执行的时候没有日志打出来，这是从效率出发。
\end_layout

\begin_layout Standard
如果zlog库有任何问题，都会打日志到ZLOG_PROFILE_ERROR所指向的错误日志。比如说，在ZLOG_INFO()上用一个错误的printf的语法：
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(zc, "%l", 1);
\end_layout

\begin_layout Standard
然后编译执行程序，ZLOG_PROFILE_ERROR的日志会是
\end_layout

\begin_layout LyX-Code
$ cat zlog.error.log 
\end_layout

\begin_layout LyX-Code
03-13 10:04:58 ERROR (10102:buf.c:189) vsnprintf fail, errno[0] 
\end_layout

\begin_layout LyX-Code
03-13 10:04:58 ERROR (10102:buf.c:191) nwrite[-1], size_left[1024], format[%l]
 
\end_layout

\begin_layout LyX-Code
03-13 10:04:58 ERROR (10102:spec.c:329) zlog_buf_vprintf maybe fail or overflow
 
\end_layout

\begin_layout LyX-Code
03-13 10:04:58 ERROR (10102:spec.c:467) a_spec->gen_buf fail 
\end_layout

\begin_layout LyX-Code
03-13 10:04:58 ERROR (10102:format.c:160) zlog_spec_gen_msg fail 
\end_layout

\begin_layout LyX-Code
03-13 10:04:58 ERROR (10102:rule.c:265) zlog_format_gen_msg fail 
\end_layout

\begin_layout LyX-Code
03-13 10:04:58 ERROR (10102:category.c:164) hzb_log_rule_output fail 
\end_layout

\begin_layout LyX-Code
03-13 10:04:58 ERROR (10102:zlog.c:632) zlog_output fail, srcfile[test_hello.c],
 srcline[41]
\end_layout

\begin_layout Standard
这样，用户就能知道为啥期待的输出没有产生，然后搞定这个问题。
\end_layout

\begin_layout Standard
运行时诊断会带来一定的性能损失。一般来说，我在生产环境把ZLOG_PROFILE_ERROR打开，ZLOG_PROFILE_DEBUG关闭。
\end_layout

\begin_layout Standard
还有另外一个办法来诊断zlog。我们都知道，zlog_init()会把配置信息读入内存。在整个写日志的过程中，这块内存保持不变。如果用户程序因为某种原因损坏了这
块内存，那么就会造成问题。还有可能是内存中的信息和配置文件的信息不匹配。所以我设计了一个函数，把内存的信息展现到ZLOG_PROFILE_ERROR指向的错误日
志。
\end_layout

\begin_layout Standard
代码见$(top_builddir)/test/test_profile.c
\end_layout

\begin_layout LyX-Code
$ cat test_profile.c
\end_layout

\begin_layout LyX-Code
#include <stdio.h>
\end_layout

\begin_layout LyX-Code
#include "zlog.h"
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
int main(int argc, char** argv)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_deeper
\begin_layout LyX-Code
int rc;
\end_layout

\begin_layout LyX-Code
rc = dzlog_init("test_profile.conf", "my_cat");
\end_layout

\begin_layout LyX-Code
if (rc) { 
\end_layout

\begin_deeper
\begin_layout LyX-Code
printf("init failed
\backslash
n");
\end_layout

\begin_layout LyX-Code
return -1;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
DZLOG_INFO("hello, zlog");
\end_layout

\begin_layout LyX-Code
zlog_profile();
\end_layout

\begin_layout LyX-Code
zlog_fini(); 
\end_layout

\begin_layout LyX-Code
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code
} 
\end_layout

\begin_layout Standard
zlog_profile()就是这个函数。配置文件很简单。
\end_layout

\begin_layout LyX-Code
$ cat test_profile.conf 
\end_layout

\begin_layout LyX-Code
@ignore_error_format_rule false 
\end_layout

\begin_layout LyX-Code
@buf_size_min 1024 
\end_layout

\begin_layout LyX-Code
@buf_size_max 0 
\end_layout

\begin_layout LyX-Code
@rotate_lock_file /tmp/zlog.lock
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
&simple "%m%n"
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
my_cat.* >stdout; simple
\end_layout

\begin_layout Standard
然后zlog.error.log会是
\end_layout

\begin_layout LyX-Code
$ cat /tmp/zlog.error.log
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:zlog.c:802) ------zlog_profile start------  
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:zlog.c:803) init_flag:[1] 
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:level.c:246) level:* = 0, 6 
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:level.c:246) level:DEBUG = 20, 7 
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:level.c:246) level:INFO = 40, 6 
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:level.c:246) level:NOTICE = 60, 5 
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:level.c:246) level:WARN = 80, 4 
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:level.c:246) level:ERROR = 100, 3 
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:level.c:246) level:FATAL = 120, 1 
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:level.c:246) level:UNKNOWN = 254, 3 
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:level.c:246) level:! = 255, 6 
\end_layout

\begin_layout Standard
这里显示了所有的等级，如果用户有自定义等级，也会在这里展示。
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:conf.c:442) ---conf[0x7fbcbed14520]--- 
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:conf.c:443) file:[test_profile.conf],mtime:[2012-03-13
 10:45:30] 
\end_layout

\begin_layout Standard
这里显示了哪一个配置文件会被读进来，以及这个文件最后修改时间。如果你对配置文件和内存中的配置信息是否一致有疑问，先比较修改时间和文件路径。在这里例子里面，ls
 -l test_profile.conf，然后和上面的数据比较。
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:conf.c:444) ignore_error_format_rule:[0] 
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:conf.c:445) buf_size_min:[1024] 
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:conf.c:446) buf_size_max:[0] 
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:conf.c:447) rotate_lock_file:[/tmp/zlog.lock]
 
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:conf.c:449) default_format: 
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:format.c:183) format:[0x14e82e0][default]-[%d(%F
 %T) %V [%p:%F:%L] %m%n] 
\end_layout

\begin_layout Standard
这里显示一些全局配置
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:conf.c:452) ---rules[0x14d5120]--- 
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:rule.c:718) rule:[0x14f8320][my_cat.0]-[,0][0x14f0300]
 
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:conf.c:457) ---formats[0x14d5420]--- 
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:format.c:183) format:[0x14f0300][simple]-[%m%n]
 
\end_layout

\begin_layout Standard
规则和格式不是那么明显
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:thread.c:260) ---tmap[0x7fbcbed16570]--- 
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:thread.c:263) thread:[140448634054400] 
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:category.c:273) ---cmap[0x7fbcbed16578]--- 
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:category.c:276) category:[my_cat] 
\end_layout

\begin_layout Standard
tmap是线程表，目前看来有一个线程。
\end_layout

\begin_layout Standard
cmap是分类表，有一个分类 -- my_cat
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:zlog.c:810) default_category[my_cat] 
\end_layout

\begin_layout Standard
最后把dzlog默认的分类打印出来
\end_layout

\begin_layout LyX-Code
03-13 11:15:19 ERROR (25631:zlog.c:812) ------zlog_profile end------ 
\end_layout

\begin_layout Section
用户自定义等级
\begin_inset CommandInset label
LatexCommand label
name "sec:Define-new-level"

\end_inset


\end_layout

\begin_layout Standard
这里我把用户自定义等级的几个步骤写下来。
\end_layout

\begin_layout Enumerate
在配置文件中定义新的等级
\end_layout

\begin_deeper
\begin_layout LyX-Code
$ cat $(top_builddir)/test/test_level.conf
\end_layout

\begin_layout LyX-Code
@ignore_error_format_rule	false 
\end_layout

\begin_layout LyX-Code
@buf_size_min			1024 
\end_layout

\begin_layout LyX-Code
@buf_size_max			0 
\end_layout

\begin_layout LyX-Code
@rotate_lock_file		/tmp/zlog.lock 
\end_layout

\begin_layout LyX-Code
@default_format			"%V %v %m%n"
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
@level				TRACE = 30, LOG_DEBUG
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
my_cat.TRACE		>stdout; 
\end_layout

\begin_layout Standard
内置的默认等级是(这些不需要写在配置文件里面)
\end_layout

\begin_layout LyX-Code
@level                DEBUG = 20, LOG_DEBUG
\end_layout

\begin_layout LyX-Code
@level                INFO = 40, LOG_INFO
\end_layout

\begin_layout LyX-Code
@level                NOTICE = 60, LOG_NOTICE
\end_layout

\begin_layout LyX-Code
@level                WARN = 80, LOG_WARNING
\end_layout

\begin_layout LyX-Code
@level                ERROR = 100, LOG_ERR
\end_layout

\begin_layout LyX-Code
@level                FATAL = 120, LOG_ALERT
\end_layout

\begin_layout LyX-Code
@level                UNKNOWN = 254, LOG_ERR
\end_layout

\begin_layout Standard
这样在zlog看来，一个整数(30)还有一个等级字符串(TRACE)代表了等级。这个整数必须位于[1,253]之间，其他数字是非法的。数字越大代表越重要。现在T
RACE比DEBUG重要(30>20)，比INFO等级低(30<40)。在这样的定义后，TRACE就可以在下面的配置文件里面用了。例如这句话：
\end_layout

\begin_layout LyX-Code
my_cat.TRACE		>stdout; 
\end_layout

\begin_layout Standard
意味着等级>=TRACE的，包括INFO, NOTICE, WARN, ERROR, FATAL会被写到标准输出。
\end_layout

\begin_layout Standard
格式里面的转换字符
\begin_inset Quotes eld
\end_inset

%V
\begin_inset Quotes erd
\end_inset

会产生等级字符串的大写输出，
\begin_inset Quotes eld
\end_inset

%v
\begin_inset Quotes erd
\end_inset

会产生小写的等级字符串输出。
\end_layout

\begin_layout Standard
另外，在等级的定义里面，LOG_DEBUG是指当需要输出到syslog的时候，自定义的TRACE等级会以LOG_DEBUG输出到syslog。
\end_layout

\end_deeper
\begin_layout Enumerate
在源代码里面直接用新的等级是这么搞的
\end_layout

\begin_deeper
\begin_layout LyX-Code
zlog(cat, __FILE__, __LINE__, 30, 
\begin_inset Quotes eld
\end_inset

test %d
\begin_inset Quotes erd
\end_inset

, 1);
\end_layout

\begin_layout Standard
为了简单使用，创建一个.h头文件
\end_layout

\begin_layout LyX-Code
$ cat $(top_builddir)/test/test_level.h
\end_layout

\begin_layout LyX-Code
#ifndef __test_level_h
\end_layout

\begin_layout LyX-Code
#define __test_level_h
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
#include "zlog.h"
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
enum {
\end_layout

\begin_deeper
\begin_layout LyX-Code
ZLOG_LEVEL_TRACE = 30,
\end_layout

\begin_layout LyX-Code
/* must equals conf file setting */ 
\end_layout

\end_deeper
\begin_layout LyX-Code
};
\end_layout

\begin_layout LyX-Code
#define ZLOG_TRACE(cat, format, args...) 
\backslash

\end_layout

\begin_layout LyX-Code
    zlog(cat, __FILE__, __LINE__, ZLOG_LEVEL_TRACE, format, ##args)
\end_layout

\begin_layout LyX-Code
#endif
\end_layout

\end_deeper
\begin_layout Enumerate
这样ZLOG_TRACE就能在.c文件里面用了
\end_layout

\begin_deeper
\begin_layout LyX-Code
$ cat $(top_builddir)/test/test_level.c
\end_layout

\begin_layout LyX-Code
#include <stdio.h> 
\end_layout

\begin_layout LyX-Code
#include "test_level.h"
\end_layout

\begin_layout LyX-Code
int main(int argc, char** argv)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_deeper
\begin_layout LyX-Code
int rc;
\end_layout

\begin_layout LyX-Code
zlog_category_t *zc;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
rc = zlog_init("test_level.conf");
\end_layout

\begin_layout LyX-Code
if (rc) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
printf("init failed
\backslash
n");
\end_layout

\begin_layout LyX-Code
return -1;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
zc = zlog_get_category("my_cat");
\end_layout

\begin_layout LyX-Code
if (!zc) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
printf("get cat fail
\backslash
n");
\end_layout

\begin_layout LyX-Code
zlog_fini();
\end_layout

\begin_layout LyX-Code
return -2;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
ZLOG_TRACE(zc, "hello, zlog - trace");
\end_layout

\begin_layout LyX-Code
ZLOG_DEBUG(zc, "hello, zlog - debug");
\end_layout

\begin_layout LyX-Code
ZLOG_INFO(zc, "hello, zlog - info");
\end_layout

\begin_layout LyX-Code
zlog_fini(); 
\end_layout

\begin_layout LyX-Code
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code
} 
\end_layout

\end_deeper
\begin_layout Enumerate
最后我们能看到输出
\end_layout

\begin_deeper
\begin_layout LyX-Code
$ ./test_level
\end_layout

\begin_layout LyX-Code
TRACE trace hello, zlog - trace 
\end_layout

\begin_layout LyX-Code
INFO info hello, zlog - info 
\end_layout

\begin_layout Standard
正是我们所期待的，配置文件只允许>=TRACE等级的日志输出到屏幕上。
\begin_inset Quotes erd
\end_inset

%V
\begin_inset Quotes erd
\end_inset

和
\begin_inset Quotes eld
\end_inset

%v
\begin_inset Quotes erd
\end_inset

也显示了正确的结果。
\end_layout

\end_deeper
\begin_layout Standard

\end_layout

\end_body
\end_document
